%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsfrench{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Decision Theoretic Troubleshooting}
\date{juin 05, 2020}
\release{}
\author{Ariana Carnielli, Ivan Kachaikin}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\index{DecisionTheoreticTroubleshooting (module)@\spxentry{DecisionTheoreticTroubleshooting}\spxextra{module}}\index{TroubleShootingProblem (classe dans DecisionTheoreticTroubleshooting)@\spxentry{TroubleShootingProblem}\spxextra{classe dans DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{TroubleShootingProblem}}}{\emph{bayesian\_network}, \emph{costs}, \emph{nodes\_types}}{}
Classe créée pour représenter un problème de Troubleshooting.
Contient des méthodes divers pour résoudre le problème.
Utilise le module pyAgrum pour manipuler le réseau bayesien utilisé pour
répresenter le problème.
Les noeuds du réseau bayésien sont réferencés par des strings.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bayesian\_network}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyAgrum.BayesNet}}) \textendash{} Représente le réseau bayésien (BN) modélisant un problème donné.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Liste avec deux dictionnaires, le premier avec les coûts de
réparation (exactes ou avec des minimun/maximun) et le deuxième
avec les coûts d’observation des noeuds.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes\_types}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire où les clés représent les noeuds du BN
et les valeurs leurs types associés (set de string).

\end{itemize}

\end{description}\end{quote}
\index{bayesian\_network (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{bayesian\_network}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.bayesian_network}}\pysigline{\sphinxbfcode{\sphinxupquote{bayesian\_network}}}
Représente le réseau bayésien (BN) qui modélise un problème donné.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pyAgrum.BayesNet

\end{description}\end{quote}

\end{fulllineitems}

\index{bay\_lp (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{bay\_lp}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.bay_lp}}\pysigline{\sphinxbfcode{\sphinxupquote{bay\_lp}}}
Fait l’inference exacte pour le BN passé en argument.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pyAgrum.LazyPropagation

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_rep (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_rep}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_rep}}}
Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts de reparation (float).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_rep\_interval (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_rep\_interval}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep_interval}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_rep\_interval}}}
Dictionnaire de coûts où les clés représentent les
noeuds du BN et les valeurs des listes avec les coûts minimum et
maximum de reparation (floats).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_obs (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_obs}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_obs}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_obs}}}
Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts d’observation (float).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{repairable\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{repairable\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.repairable_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{repairable\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments du
système concerné qui peuvent être réparés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{unrepairable\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{unrepairable\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.unrepairable_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{unrepairable\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments
d’un système qui ne peuvent pas être réparés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{problem\_defining\_node (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{problem\_defining\_node}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.problem_defining_node}}\pysigline{\sphinxbfcode{\sphinxupquote{problem\_defining\_node}}}
Noeud qui répresent le problème a être reglé
(système fonctionnel où pas).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{observation\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{observation\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{observation\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments
du système qui peuvent être observés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{service\_node (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{service\_node}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.service_node}}\pysigline{\sphinxbfcode{\sphinxupquote{service\_node}}}
Noeud qui répresent l’appel au service (appel à la
réparation sûre du système).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{evidences (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{evidences}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.evidences}}\pysigline{\sphinxbfcode{\sphinxupquote{evidences}}}
Dictionnaire ou les clés répresentent les élements du
système qui ont des evidences modifiés dans bay\_lp (donc qui ont
été réparés/observés) et les valeurs sont les inferences faites.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{ECR\_ECO\_wrapper() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{ECR\_ECO\_wrapper()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.ECR_ECO_wrapper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ECR\_ECO\_wrapper}}}{\emph{debug=False}}{}
Calcule l’ECR myope pour chaque prochaine « observation\sphinxhyphen{}réparation »
possible et l’ECO pour chaque prochaine observation globale possible.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{chosen\_node} (\sphinxstyleemphasis{string}) \textendash{} Noeud choisi.

\item {} 
\sphinxstylestrong{type\_node} (\sphinxstyleemphasis{string}) \textendash{} Type du noeud choisi (« repair » ou « obs »).

\item {} 
\sphinxstylestrong{list\_ecr} (\sphinxstyleemphasis{list(tuple)}) \textendash{} ECRs des noeuds d“« observation\sphinxhyphen{}réparation ».

\item {} 
\sphinxstylestrong{list\_eco} (\sphinxstyleemphasis{list(tuple)}) \textendash{} ECOs des noeuds d’observation globale.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_compute\_costs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_compute\_costs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._compute_costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_compute\_costs}}}{\emph{costs}}{}
Prend en argument un dictionnaire de couts qui peut avoir des valeurs
exactes ou des intervalles de valeurs (de la forme {[}minimum, maximum{]})
et le transforme en 2 dictionnaires, un avec les esperances de cout
pour chaque clé et l’autre avec des intervalles de valeurs pour chaque
clé.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de couts où les clés représentent les noeuds
du BN et les valeurs sont de nombres ou de listes de deux
nombres.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{expected\_cost} (\sphinxstyleemphasis{dict}) \textendash{} Dictionnaire où les clés représentent les noeuds du
BN et les valeurs l’esperance de cout de ce noeud. Si la valeur
initiale était déjà un nombre, ce nombre est seulement copié,
sinon on considère que la valeur est une variable aléatoire
avec une distribution uniforme dans l’intervalle et donc
l’esperance est la moyenne des extremités de l’intervalle.

\item {} 
\sphinxstylestrong{interval\_cost} (\sphinxstyleemphasis{dict}) \textendash{} Dictionnaire où les clés représentent les noeuds du
BN et les valeurs sont des listes contenant les deux extremités
des intervalles dans lequels les couts se trouvent. Si la
valeur initiale était déjà un nombre, ce nombre est copié comme
les deux extremités. Si la valeur initiale était un iterable,
on le transforme en liste.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_create\_nodes() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_create\_nodes()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._create_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_create\_nodes}}}{\emph{names}, \emph{rep\_string=\textquotesingle{}\_repair\textquotesingle{}}, \emph{obs\_string=\textquotesingle{}\_observation\textquotesingle{}}, \emph{obs\_rep\_couples=False}}{}
Crée des noeuds de StrategyTree à partir de leurs noms dans le réseau
Bayésien.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{names}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Noms des noeuds de réparations/observations/
observations\sphinxhyphen{}réparations dans le réseau Bayésien à partir desquels
on crée les noeuds.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rep\_string}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dans le cas où on ne considère pas des couples, on utilise ce
paramètre comme un suffixe pour les noeuds de réparation pour les
séparer de ceux d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_string}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Suffixe pour les noeuds d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Variable boléenne qui indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{nodes} \textendash{} Liste de noeuds crées.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{\_evaluate\_all\_st() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_evaluate\_all\_st()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._evaluate_all_st}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_evaluate\_all\_st}}}{\emph{feasible\_nodes}, \emph{obs\_next\_nodes=None}, \emph{parent=None}, \emph{fn\_immutable=None}, \emph{debug\_nb\_call=0}, \emph{debug\_iter=False}, \emph{debug\_st=False}, \emph{obs\_rep\_couples=False}, \emph{obs\_obsolete=False}, \emph{sock=None}}{}
Méthode récursive qui trouve le meilleur arbre de stratégie étant donné
une configuration du problème en dénombrant tous les arbres
admissibles.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feasible\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Lisste des noeuds admissibles qu’on a le droit d’utiliser pour
construire l’arbre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_next\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Pile des attributs des arcs qui partent des noeuds déjà utilisés.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} StrategyTree.StrategyTree)), facultatif
Pile des \sphinxstyleemphasis{parents} vers lesquels il faudra se retourner quand on
remplit entièrement la branche courante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_immutable}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Pile des noeuds admissibles qu’on peut utiliser pour les branches
différentes qui suivent un noeud d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_nb\_call}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Profondeur de la récursivité.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher l’index de l’itération de l’appel.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_st}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Précise s’il faut afficher tous les arbres intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie soumis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. qu’une observation devient obsolète en réparant une
composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_expected\_cost\_of\_repair\_internal() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_expected\_cost\_of\_repair\_internal()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._expected_cost_of_repair_internal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_expected\_cost\_of\_repair\_internal}}}{\emph{strategy\_tree}, \emph{evid\_init=None}, \emph{prob=1.0}, \emph{obs\_obsolete=False}}{}
Partie récursive de la fonction expected\_cost\_of\_repair.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}) \textendash{} Arbre de stratégie dont le coût il faut calculer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evid\_init}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str: str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire d’évidences utilisé dans les appels récursifs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Probabilité initiale.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, on remet en cause les noeuds d’observation globale après
une réparation.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation d’un arbre de stratégie fourni.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_next\_node\_id() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_next\_node\_id()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._next_node_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_next\_node\_id}}}{}{}
Permet d’obtenir la prochaine valeur de \sphinxstyleemphasis{id} pour un noeud de
StrategyTree à partir des ids qu’on utilise déjà stockés dans
\sphinxstyleemphasis{self.\_nodes\_ids\_db\_brute\_force}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{next\_id} \textendash{} Prochain id qu’on peut utiliser avec garantie qu’il n’existe pas de
noeuds déjà avec le même id dans l’arbre de stratégie courant.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_start\_bay\_lp() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_start\_bay\_lp()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._start_bay_lp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_start\_bay\_lp}}}{}{}
Ajoute des inférences vides aux noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés).Ces évidences ne changent pas les
probabilités, elles servent pour qu’on puisse utiliser la méthode
chgEvidence de pyAgrum à la suite.

\end{fulllineitems}

\index{add\_evidence() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{add\_evidence()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.add_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_evidence}}}{\emph{node}, \emph{evidence}}{}
Fonction wrapper pour la fonction chgEvidence de l’objet bay\_lp du
type pyAgrum.LazyPropagation qui additionne une inference et mantient
le dictionnaire evidences actualisé. L’evidence passé en argument ne
doit pas être une evidence « vide » (des 1, utilisé plutôt la fonction
remove\_evidence).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp qui va être modifié.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} Nouvelle inference pour le noeud traité (généralement
une string ici, cf. les types acceptés par chgEvidence)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{best\_EVOI() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{best\_EVOI()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.best_EVOI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{best\_EVOI}}}{}{}
Détermine la composante qui a la plus grande valeur espérée
d’information (EVOI) correspondant à avoir plus d’information sur
l’intervalle de valeur de son cout.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
Le nom du noeud de réparation avec la plus grande EVOI et la valeur
d’EVOI correspondante.

\item[{Type renvoyé}] \leavevmode
tuple(string, float)

\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver}}}{\emph{debug=False}, \emph{mode=\textquotesingle{}all\textquotesingle{}}, \emph{obs\_rep\_couples=False}, \emph{obs\_obsolete=False}, \emph{sock=None}}{}
Wrapper des différents algorithmes de recherche exhaustive qui calcule
la solution exacte optimale étand donné un problème de Troubleshooting.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool / tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher les résultats intermédiaires du calcul.
Un tuple avec len(tuple) == 2 ou un booléean (équivalent au cas où
on passe un tuple avec deux valeurs identiques). Le premier
composant indique s’il faut afficher l’index de l’itération tandis
que le deuxième précise s’il faut afficher tous les arbres
intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Mode de calcul : soit “dp” pour la programmation dynamique, soit
“all” pour le dénombrement complet.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose des couples « observation\sphinxhyphen{}réparation  » dans
l’arbre de stratégie.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. si c’est possible qu’une observation devient obsolète en
réparant une composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{best\_st} (\sphinxstyleemphasis{StrategyTree.StrategyTree}) \textendash{} Le meilleur arbre de stratégie trouvé.

\item {} 
\sphinxstylestrong{best\_ecr} (\sphinxstyleemphasis{float}) \textendash{} Le coût espéré de réparation du meilleur arbre trouvé i.e.
ECR(\sphinxstyleemphasis{best\_st}).

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver\_actions\_only() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver\_actions\_only()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_actions_only}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver\_actions\_only}}}{\emph{debug=False}}{}
Cherche une séquence optimale de réparation par une recherche
exhaustive en choisissant la séquence de meilleur ECR. Pour le cas où
on ne considère que les actions de réparation il suffit de dénombrer
toutes les permutations possibles d’un ensemble des actions
admissibles.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{min\_seq} (\sphinxstyleemphasis{list(str)}) \textendash{} Séquence optimale trouvée dont le coût est le plus petit possible.

\item {} 
\sphinxstylestrong{min\_ecr} (\sphinxstyleemphasis{float}) \textendash{} Coût espéré de réparation correspondant à min\_seq.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{strategy\_tree=None}, \emph{mode=\textquotesingle{}dp\textquotesingle{}}, \emph{obs\_rep\_couples=False}, \emph{true\_prices\_obs=None}}{}
Test empirique de la méthode brute\_force\_solver, ou bien de l’arbre de
stratégie obtenu par l’algorithme. Le mécanisme selon lequel on teste
la stratégie est exactement le même que celui utilisé au\sphinxhyphen{}dessus
dans les autres testers.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Arbre de stratégie qu’il faut tester ; si rien passé, on calcule
l’arbre avec la méthode brute\_force\_solver.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Paramètre à passer à la méthode brute\_force\_solver si on doit
l’exécuter. Peut être égal à “all” pour le dénombrement complet ou
“dp” pour la programmation dynamique.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Paramètre à passer à la méthode brute\_force\_solver si on doit
l’exécuter. Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire de prix d’observations des composantes observables.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_EVOIs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{compute\_EVOIs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.compute_EVOIs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_EVOIs}}}{}{}
Calcule les valeurs espérées d’information (EVOIs) correspondant à
avoir plus d’information sur l’intervalle de valeur des couts de
réparation pour chaque composante réparable.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{evoi} \textendash{} Dictionnaire indexé par les noeuds réparables contenant la valeur
d’une information plus précise du cout de réparation de ces noeuds.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{draw\_true\_prices() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{draw\_true\_prices()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.draw_true_prices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{draw\_true\_prices}}}{}{}
Tire au hasard des prix de réparation selon des lois uniformes sur les
intervalles stockés dans self.costs\_rep\_interval.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
Dictionnaire avec prix de réparation.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{dynamic\_programming\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{dynamic\_programming\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.dynamic_programming_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dynamic\_programming\_solver}}}{\emph{feasible\_nodes=None}, \emph{evidence=None}, \emph{debug\_iter=False}, \emph{debug\_st=False}, \emph{obs\_rep\_couples=False}, \emph{prob=1.0}, \emph{obs\_obsolete=False}, \emph{sock=None}, \emph{debug\_nb\_call=0}}{}
Méthode récursive qui trouve le meilleur arbre de stratégie étant donné
une configuration du problème en utilisant comme approche la
programmation dynamique, supposant qu’un sous\sphinxhyphen{}arbre de l’arbre optimal
est lui\sphinxhyphen{}même également optimal.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feasible\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Liste des noeuds admissibles qu’on a le droit d’utiliser pour
construire l’arbre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire des évidences initiales pour un appel de cette
fonction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher l””index de l’itération dans l’appel.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_st}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Précise s’il faut afficher tous les arbres intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie soumis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Probabilité que le système ne marche toujours pas.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. qu’une observation devient obsolète en réparant une
composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_nb\_call}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Profondeur de la récursivité.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{elicitation() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{elicitation()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{elicitation}}}{\emph{noeud}, \emph{islower}}{}
Met à jour l’intervalle de valeurs de cout pour le noeud et son
espérance en fonction de la réponse de l’utilisateur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noeud}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud à mettre à jour.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{islower}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Représente la réponse à la question : Est\sphinxhyphen{}ce que le cout est plus
petit que l’espérance courante ?

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{elicitation\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{elicitation\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{elicitation\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{debug=False}}{}
Test empirique de la résolution avec élicitation. À chaque fois qu’on
doit prendre une action, on vérifie d’abord s’il y a des questions à
répondre et, si oui, on les répond toutes correctement selon
true\_prices. Ensuite, la méthode calcule la séquence d’actions
itérativement à l’aide de myopic\_solver et réalise au plus nb\_max
repetitions d’un système tiré au hasard, le tirage au hasard étant
identique à celui de myopic\_solver\_tester. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\item {} 
\sphinxstylestrong{cpt\_questions} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de questions répondues à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{expected\_cost\_of\_repair() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{expected\_cost\_of\_repair()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{expected\_cost\_of\_repair}}}{\emph{strategy\_tree}, \emph{obs\_obsolete=False}}{}
Calcule le coût espéré de réparation étant donné un arbre de décision.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}) \textendash{} Arbre de stratégie dont le coût il faut calculer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, on remet en cause les noeuds d’observation globale après
une réparation.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation d’un arbre de stratégie fourni.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{expected\_cost\_of\_repair\_seq\_of\_actions() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{expected\_cost\_of\_repair\_seq\_of\_actions()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair_seq_of_actions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{expected\_cost\_of\_repair\_seq\_of\_actions}}}{\emph{seq}}{}
Calcule un coût espéré de réparation à partir d’une séquence d’actions
donnée. On utilise la formule
ECR = coût(C1 | E0)
+ P(C1 = Normal | E0) * coût(C2 | E1)
+ P(C1 = Normal | E0) * P(C2 = Normal | E1) * coût(C2 | E2)
+ …
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{seq}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Séquence d’actions de réparations dont le coût espéré est à
calculer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation de la séquence donnée.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_proba() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{get\_proba()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.get_proba}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_proba}}}{\emph{node}, \emph{value}}{}
Récupère à partir du réseau bayésien la probabilité que le noeud node
ait la valeur value.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp dont on veut calculer la probabilité.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Valeur du noeud dont on veut calculer la probabilité.

\end{itemize}

\item[{Renvoie}] \leavevmode
La probabilité P(node = value)

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver}}}{\emph{debug=False}, \emph{esp\_obs=False}}{}
Implémente une étape du solveur myope. Étant donné l’état actuel du
réseau, ce solveur utilise dans un premier temps le simple\_solver\_obs
pour déterminer quelle action du type « observation\sphinxhyphen{}réparation » serait
la meilleure. Ensuite, il calcule les coûts myopes espérés avec chaque
observation possible et choisit à la fin la meilleure action à être
prise.

Cette fonction est itérative et ne fait qu’un seul tour de
l’algorithme myope car elle attend des nouvelles informations venues
de l’utilisateur (résultat de l’observation si c’est le cas).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{esp\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, retourne en plus un dictionnaire indexé par les
observations possibles et contenants leurs couts myopes espérés
respectifs.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{chosen\_node} (\sphinxstyleemphasis{string}) \textendash{} Le meilleur noeud de ce tour

\item {} 
\sphinxstylestrong{type\_node} (\sphinxstyleemphasis{string}) \textendash{} Type du meilleur noeud (« repair » ou « obs »)

\item {} 
\sphinxstylestrong{eco} (\sphinxstyleemphasis{dict}) \textendash{} Retourné uniquement lorsque esp\_obs vaut True. Dictionnaire des
couts espérés des observations.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver\_st() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver\_st()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_st}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver\_st}}}{\emph{evid\_init=None}}{}
Une méthode qui récupère un arbre de stratégie qu’on peut construire à partir de myopic\_solver.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{evid\_init}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un dictionnaire des évidences par défaut.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{strat\_tree} \textendash{} Un arbre de stratégie qu’on construit utilisant pas\sphinxhyphen{}à\sphinxhyphen{}pas une méthode myopic\_solver en remplissant cet arbre
en largeur.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree.StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{debug=False}}{}
Test empirique de la méthode myopic\_solver. Cette méthode calcule
la séquence d’actions itérativement à l’aide de myopic\_solver et
réalise au plus nb\_max repetitions d’un système tiré au hasard. À
chaque observation globale, son résultat est tiré au hasard. Pour les
paires « observation\sphinxhyphen{}réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_wraper() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_wraper()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_wraper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_wraper}}}{\emph{debug=False}}{}
Interface textuelle pour le solveur myope. Utilise myopic\_solver à
chaque tour de boucle pour déterminer la meilleure action à prendre.
Si c’est une observation, le résultat de l’observation est demandé,
sinon on demande juste si l’action a résolu le problème. Les
élicitations de couts ne sont pas implémentées. Les entrées de
l’utilisateur ne sont pas sécurisées.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{description}\end{quote}

\end{fulllineitems}

\index{noeud\_ant() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{noeud\_ant()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.noeud_ant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{noeud\_ant}}}{\emph{node}, \emph{visites}}{}
Détermine tous les noeuds d’observation impactés par un changement
du noeud node et qui sont antécesseurs de node, sans visiter les noeuds
déjà dans l’ensemble des visites. Cette fonction est auxiliaire et n’a
pas vocation à être appellée en dehors de la fonction principale
observation\_obsolete.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud don l’information a changé.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visites}} (\sphinxstyleliteralemphasis{\sphinxupquote{set}}) \textendash{} Contient les noeuds déjà visités.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ant\_obs} \textendash{} Ensemble des noeuds d’observation affectés par node et qui sont
antecesseurs de node sans être dans visites.

\item[{Type renvoyé}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{observation\_obsolete() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{observation\_obsolete()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_obsolete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{observation\_obsolete}}}{\emph{node}}{}
Étant donné un noeud dont l’information a changé, on détermine, à
partir du réseau bayésien, tous les noeuds d’observation impactés par
ce chagement.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud dont l’information a changé.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{obs} \textendash{} Ensemble contenant les noeuds d’observation impactés.

\item[{Type renvoyé}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_evidence() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{remove\_evidence()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.remove_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_evidence}}}{\emph{node}}{}
Fonction wrapper pour la fonction chgEvidence de l’objet bay\_lp du
type pyAgrum.LazyPropagation qui retire une inference et mantient le
dictionnaire evidences actualisé.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp qui va être modifié.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_bay\_lp() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{reset\_bay\_lp()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.reset_bay_lp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_bay\_lp}}}{\emph{dict\_inf=\{\}}}{}
Reinitialise les inférences des noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés). Pour les noeuds dans dict\_inf, l’inférence
est mis à la valeur associé au noeud dans dict\_inf, pour les autres
l’inférence est mis à 1.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{dict\_inf}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire où les clés sont des noeuds et les valeurs sont des
inférences.

\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver}}}{\emph{debug=False}}{}
Solveur simple pour le problème du TroubleShooting.
On ne prend pas en considèration des observations et on ne révise pas
les probabilités, c’est\sphinxhyphen{}à\sphinxhyphen{}dire on ne met pas à jour les probabilités
si on répare une composante.
À cause de cela, ce solveur n’est pas iteractif et renvoie l’ordre de
réparation entière (jusqu’au appel au service).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rep\_seq} (\sphinxstyleemphasis{list}) \textendash{} Séquence des noeuds à être réparés dans l’ordre.

\item {} 
\sphinxstylestrong{exp\_cost} (\sphinxstyleemphasis{float}) \textendash{} Espérance du coût de réparation de cette séquence.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_obs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_obs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_obs}}}{\emph{debug=False}}{}
Solveur simple pour le problème du Troubleshooting.
On prend en considèration des paires « observation\sphinxhyphen{}réparation » (cf.
définition dans l’état de l’art) mais pas les observations globales
et on révise les probabilités, c’est\sphinxhyphen{}à\sphinxhyphen{}dire on met à jour les
probabilités quand on « répare » une composante avant de calculer le
prochaine composante de la séquence.

Le solveur n’est pas encore iteractif et renvoie l’ordre de réparation
entière (jusqu’au appel au service). Cette choix à été fait car on
utilise cet algorithme comme part de l’agorithme plus complexe et
iteratif.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rep\_seq} (\sphinxstyleemphasis{list}) \textendash{} Séquence des noeuds à être réparés dans l’ordre.

\item {} 
\sphinxstylestrong{exp\_cost} (\sphinxstyleemphasis{float}) \textendash{} Espérance du coût de réparation de cette séquence.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_obs\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_obs\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_obs\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}}{}
Test empirique de la méthode simple\_solver\_obs. Cette méthode calcule
la séquence d’actions à l’aide de simple\_solver\_obs et réalise au plus
nb\_max répétitions d’un système tiré au hasard : si on a une paire
« observation\sphinxhyphen{}réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}}{}
Test empirique de la méthode simple\_solver. Cette méthode calcule la
séquence d’actions à l’aide de simple\_solver et réalise au plus nb\_max
repétitions d’un système tiré au hasard : à chaque fois qu’on a une
probabilité qu’une action résoud le problème, on tire au hasard pour
déterminer si le problème a effectivement été résolu ou pas suite à
cette action. Si après nb\_min repétitions l’erreur estimée est plus
petite que epsilon, on fait une sortie anticipée. La fonction calcule
aussi les couts empiriques de réparation, en utilisant pour cela
true\_prices. Cette méthode utilise la single fault assumption.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{bcolors (classe dans DecisionTheoreticTroubleshooting)@\spxentry{bcolors}\spxextra{classe dans DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.bcolors}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{bcolors}}}
Stockage de couleurs.

\end{fulllineitems}

\index{diff\_dicts() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{diff\_dicts()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.diff_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{diff\_dicts}}}{\emph{left}, \emph{right}}{}
Calcule la différence des dictionnaires \sphinxstyleemphasis{left} et \sphinxstyleemphasis{right} : les entrées de
\sphinxstyleemphasis{left} dont la clé est aussi présente dans \sphinxstyleemphasis{right} sont supprimées, les
autres sont gardées.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{left}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Premier dictionnaire, duquel on supprime les clés apparaissant dans
\sphinxstyleemphasis{right}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Deuxième dictionnaire, celui avec les clés qui doivent être supprimées
de \sphinxstyleemphasis{left}.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{res} \textendash{} Résultat de la différence entre \sphinxstyleemphasis{left} et \sphinxstyleemphasis{right}.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{merge\_dicts() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{merge\_dicts()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.merge_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{merge\_dicts}}}{\emph{left}, \emph{right}}{}
Fusionne deux dictionnaire passés sans les changer. Les couples (clé,
valeur) du dictionnaire \sphinxstyleemphasis{right} sont plus prioritaires que celles de
\sphinxstyleemphasis{left} ; c’est\sphinxhyphen{}à\sphinxhyphen{}dire, s’il existe une valeur associée à la même clé k dans
les deux dictionnaires, on ajoute dans le résultat seulement celle qui
appartient à \sphinxstyleemphasis{right}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{left}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Un des dictionnaires à fusionner, celui qui est moins prioritaire.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} L’autre dictionnaire à fusionner, celui qui est plus prioritaire.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{res} \textendash{} Résultat de la fusion.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{shallow\_copy\_list\_of\_copyable() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{shallow\_copy\_list\_of\_copyable()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.shallow_copy_list_of_copyable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{shallow\_copy\_list\_of\_copyable}}}{\emph{l}}{}
Crée une copie de profondeur 1 de la liste passée en argument : la liste
est recopiée et remplie avec l’appel de la méthode copy() en chaque élément
de la liste donnée.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\textless{}Copyable\textgreater{}}}) \textendash{} La liste qui sera copiée. Chacun de ses éléments doit implémenter la
méthode copy().

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{cl} \textendash{} Copie de profondeur 1 de la liste passée en argument.

\item[{Type renvoyé}] \leavevmode
list\textless{}Copyable\textgreater{}

\end{description}\end{quote}

\end{fulllineitems}

\index{shallow\_copy\_parent() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{shallow\_copy\_parent()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.shallow_copy_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{shallow\_copy\_parent}}}{\emph{parent}}{}
Crée une copie superficielle de \sphinxstyleemphasis{parent} (cf la méthode
TroubleShootingProblem.\_evaluate\_all\_st ci\sphinxhyphen{}dessous).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Parent dont la copie il faut créer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{parent\_copy} \textendash{} Copie superficielle du parent passé.

\item[{Type renvoyé}] \leavevmode
list(tuple({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree.StrategyTree}}}))

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-StrategyTree}}\index{StrategyTree (module)@\spxentry{StrategyTree}\spxextra{module}}\index{NodeST (classe dans StrategyTree)@\spxentry{NodeST}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{NodeST}}}{\emph{id}, \emph{cost}, \emph{name=None}}{}
Classe qui représente un noeud plutôt abstrait d’un arbre de stratégie ; on remarque que cette classe ne dispose pas
d’un enfant (il n’y a pas d’un attribut qui correspond à un noeud suivant), pourtant, on suppose que ses sous\sphinxhyphen{}
classes en auront.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Un attribut qui correspond à « coût » d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom d’un noeud qui peut être pas unique ; si rien a été soumis, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.NodeST)@\spxentry{\_id}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.NodeST)@\spxentry{\_cost}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Un attribut qui correspond à « coût » d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_name (attribut StrategyTree.NodeST)@\spxentry{\_name}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._name}}\pysigline{\sphinxbfcode{\sphinxupquote{\_name}}}
Un nom d’un noeud qui peut être pas unique ; si rien a été passé, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id\_}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (méthode StrategyTree.NodeST)@\spxentry{\_\_eq\_\_()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.__eq__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_eq\_\_}}}{\emph{other}}{}
Overloading d’opérateur \_\_eq\_\_ ; on dit que deux noeuds sont égaux ssi ils ont les mêmes ids.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Un autre noeud à comparer avec celui\sphinxhyphen{}ci.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{comp\_res} \textendash{} True, si self.\_id == other.\_id ET si self et other ont le même type ; False, sinon.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_str\_\_() (méthode StrategyTree.NodeST)@\spxentry{\_\_str\_\_()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
Overloading d’opérateur \_\_str\_\_.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{corr\_str} \textendash{} Une représentation d’un noeud sous une forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.NodeST)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Une méthode abstraite qui ajouterait un enfant d’un noeud.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Un enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.NodeST)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Une méthode abstraite qui retournera un dictionnaire des associations entre des labels d’un réseau
bayésien et des enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Un dictionnaire des associations concerné.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.NodeST)@\spxentry{copy()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Une méthode qui retournerait une copie superficielle d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Une copie superficielle d’un noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.NodeST)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Une méthode abstraite qui retournerait un enfant d’un noeud correspondant à attr.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un attribut (un type) d’enfant qu’il faudrait retourner.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} Un enfant d’un noeud qui correspond à un attribut soumis.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_cost() (méthode StrategyTree.NodeST)@\spxentry{get\_cost()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_cost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_cost}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_cost}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_cost} \textendash{} Une valeur de coût d’un noeud.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_id() (méthode StrategyTree.NodeST)@\spxentry{get\_id()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_id} \textendash{} Identificateur unique courant d’un noeud.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.NodeST)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Une méthode abstraite qui permettrait d’obtenir une liste de tous les enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} Une liste de tous les enfants d’un noeud.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_name() (méthode StrategyTree.NodeST)@\spxentry{get\_name()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_name}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_name}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_name} \textendash{} Un nom d’un noeud.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.NodeST)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Une méthode abstraite qui mettrait en place un enfant d’un noeud correspondant à attr.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un attribut (un type) d’enfant qu’il faudrait mettre en place.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à un attribut soumis et qu’il faut mettre en place.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cost() (méthode StrategyTree.NodeST)@\spxentry{set\_cost()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_cost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_cost}}}{\emph{cost}}{}
Setter d’un attribut \sphinxstyleemphasis{\_cost}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Une valeur de coût d’un noeud à mettre en place.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_id() (méthode StrategyTree.NodeST)@\spxentry{set\_id()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_id}}}{\emph{id}}{}
Setter d’un attribut \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique d’un noeud pour mettre en place.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_name() (méthode StrategyTree.NodeST)@\spxentry{set\_name()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_name}}}{\emph{name}}{}
Setter d’un attribut \sphinxstyleemphasis{\_name}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un nom d’un noeud pour mettre en place.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Observation (classe dans StrategyTree)@\spxentry{Observation}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{Observation}}}{\emph{id}, \emph{cost}, \emph{name=None}, \emph{yes\_child=None}, \emph{no\_child=None}, \emph{obs\_rep\_couples=False}}{}
Classe qui représente un noeud de type correspondant à une action d’observation.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Un attribut qui correspond à « coût » d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom d’un noeud qui peut être pas unique ; si rien a été soumis, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{yes\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à une branche « yes ».

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à une branche « no ».

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un attribut sous la forme d’une variable boléenne qui indique si le noeud représente une couple
observation\sphinxhyphen{}réparation ou pas.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.Observation)@\spxentry{\_id}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.Observation)@\spxentry{\_cost}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Un attribut qui correspond à « coût » d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_name (attribut StrategyTree.Observation)@\spxentry{\_name}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._name}}\pysigline{\sphinxbfcode{\sphinxupquote{\_name}}}
Un nom d’un noeud qui peut être pas unique ; si rien a été passé, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_yes\_child (attribut StrategyTree.Observation)@\spxentry{\_yes\_child}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._yes_child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_yes\_child}}}
Un enfant d’un noeud qui correspond à une branche « yes ».
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_no\_child (attribut StrategyTree.Observation)@\spxentry{\_no\_child}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._no_child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_no\_child}}}
Un enfant d’un noeud qui correspond à une branche « no ».
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_obs\_rep\_couples (attribut StrategyTree.Observation)@\spxentry{\_obs\_rep\_couples}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._obs_rep_couples}}\pysigline{\sphinxbfcode{\sphinxupquote{\_obs\_rep\_couples}}}
Un attribut sous la forme d’une variable boléenne qui indique si le noeud représente une couple
observation\sphinxhyphen{}réparation ou pas
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.Observation)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Une méthode qui ajoute littéralement un enfant dans une liste des enfants d’un noeud.
ATTENTION : ce méthode ne peut pas changer un enfant qui existe déjà ; pour cela, veuillez utiliser set\_child !
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Un enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.Observation)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Une méthode plutôt auxiliare qui retourne un dictionnaire des associations entre des labels d’un réseau
bayésien et des enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Un dictionnaire des associations concerné.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.Observation)@\spxentry{copy()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Une méthode qui retourne une copie superficielle d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Une copie superficielle d’un noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.Observation}]{\sphinxcrossref{Observation}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.Observation)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Une méthode qui retourne un enfant d’un noeud correspondant à l’attribut de la branche soumise.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Attribut de la branche.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} Un enfant correspondant à l’attribut.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.Observation)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Une méthode qui retourne une liste avec tous les enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} Une liste avec tous les enfants d’un noeud.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_no\_child() (méthode StrategyTree.Observation)@\spxentry{get\_no\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_no_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_no\_child}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_no\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_no\_child} \textendash{} Un enfant d’un noeud qui correspond à une branche « no ».

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_obs\_rep\_couples() (méthode StrategyTree.Observation)@\spxentry{get\_obs\_rep\_couples()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_obs_rep_couples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_obs\_rep\_couples}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_obs\_rep\_couples}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_obs\_rep\_couples} \textendash{} Un attribut sous la forme d’une variable boléenne qui indique si le noeud représente une couple
observation\sphinxhyphen{}réparation ou pas.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_yes\_child() (méthode StrategyTree.Observation)@\spxentry{get\_yes\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_yes_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_yes\_child}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_yes\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_yes\_child} \textendash{} Un enfant d’un noeud qui correspond à une branche « yes ».

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.Observation)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Une méthode qui met en place un enfant d’un noeud correspondant à l’attribut de la branche soumise.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Attribut de la branche.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant qu’il faut mettre en place.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_no\_child() (méthode StrategyTree.Observation)@\spxentry{set\_no\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_no_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_no\_child}}}{\emph{no\_child=None}}{}
Setter d’un attribut \sphinxstyleemphasis{\_no\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{no\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à une branche « no ».

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_obs\_rep\_couples() (méthode StrategyTree.Observation)@\spxentry{set\_obs\_rep\_couples()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_obs_rep_couples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_obs\_rep\_couples}}}{\emph{obs\_rep\_couples}}{}
Setter d’un attribut \sphinxstyleemphasis{\_obs\_rep\_couples}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Un attribut sous la forme d’une variable boléenne qui indique si le noeud représente une couple
observation\sphinxhyphen{}réparation ou pas.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_yes\_child() (méthode StrategyTree.Observation)@\spxentry{set\_yes\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_yes_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_yes\_child}}}{\emph{yes\_child=None}}{}
Setter d’un attribut \sphinxstyleemphasis{\_yes\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{yes\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à une branche « yes ».

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Repair (classe dans StrategyTree)@\spxentry{Repair}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{Repair}}}{\emph{id}, \emph{cost}, \emph{name=None}, \emph{child=None}}{}
Classe qui représente un noeud de type plus précis : celui correspondant à une action de réparation.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Un attribut qui correspond à « coût » d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom d’un noeud qui peut être pas unique ; si rien a été soumis, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.Repair)@\spxentry{\_id}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.Repair)@\spxentry{\_cost}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Un attribut qui correspond à « coût » d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_name (attribut StrategyTree.Repair)@\spxentry{\_name}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._name}}\pysigline{\sphinxbfcode{\sphinxupquote{\_name}}}
Un nom d’un noeud qui peut être pas unique ; si rien a été passé, on pose que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_child (attribut StrategyTree.Repair)@\spxentry{\_child}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_child}}}
Un enfant d’un noeud, c’est\sphinxhyphen{}à\sphinxhyphen{}dire, un noeud suivant dans un arbre.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.Repair)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Une méthode qui ajoute littéralement un enfant dans une liste des enfants d’un noeud.
ATTENTION : ce méthode ne peut pas changer un enfant qui existe déjà ; pour cela, veuillez utiliser set\_child !
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Un enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.Repair)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Une méthode plutôt auxiliare qui retourne un dictionnaire des associations entre des labels d’un réseau
bayésien et des enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Un dictionnaire des associations concerné.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.Repair)@\spxentry{copy()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Une méthode qui retourne une copie superficielle d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Une copie superficielle d’un noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.Repair}]{\sphinxcrossref{Repair}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child() (méthode StrategyTree.Repair)@\spxentry{get\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child}}}{}{}
Getter d’un attribut \sphinxstyleemphasis{\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_child} \textendash{} Un enfant d’un noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.Repair)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Une méthode qui réalise une version abstraite de superclass ; comme ce type de noeud ne dispose que d’un seul
enfant, on y retourne toujours cet enfant pour n’importe quel attr indiqué
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un attribut (un type) d’enfant qu’il faudrait retourner.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} Un enfant d’un noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.Repair)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Une méthode qui retourne une liste qui contient tous les enfants d’un noeud ; pour ce cas\sphinxhyphen{}là alors, soit
une liste avec un seul élément, soit une liste vide.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} Une liste de tous les enfants d’un noeud (soit une liste avec un seul élément, soit une liste vide).

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child() (méthode StrategyTree.Repair)@\spxentry{set\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.set_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child}}}{\emph{child=None}}{}
Setter d’un attribut \sphinxstyleemphasis{\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.Repair)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Une méthode qui met en place un enfant d’un noeud correspondant à attr réalisant une méthode correspondante
superclass.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un attribut (un type) d’enfant qu’il faut mettre en place.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un enfant d’un noeud qui correspond à un attribut soumis et qu’il faut mettre en place.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StrategyTree (classe dans StrategyTree)@\spxentry{StrategyTree}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{StrategyTree}}}{\emph{root=None}, \emph{nodes=None}}{}
Une classe pour représenter un arbre de stratégie qui fait face au problème de Troubleshooting.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Une racine de l’arbre, i.e. une action pour commencer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Une liste des noeuds de l’arbre.

\end{itemize}

\end{description}\end{quote}
\index{\_root (attribut StrategyTree.StrategyTree)@\spxentry{\_root}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._root}}\pysigline{\sphinxbfcode{\sphinxupquote{\_root}}}
Une racine de l’arbre, i.e. une action pour commencer.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_nodes (attribut StrategyTree.StrategyTree)@\spxentry{\_nodes}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_nodes}}}
Une liste des noeuds de l’arbre.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{\_adj\_dict (attribut StrategyTree.StrategyTree)@\spxentry{\_adj\_dict}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._adj_dict}}\pysigline{\sphinxbfcode{\sphinxupquote{\_adj\_dict}}}
Un dictionnaire pour indiquer lesquels noeuds sont liés par des arcs.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{fout\_newline (attribut StrategyTree.StrategyTree)@\spxentry{fout\_newline}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.fout_newline}}\pysigline{\sphinxbfcode{\sphinxupquote{fout\_newline}}}
Un attribut utilisé pour indiquer le début d’une nouvelle ligne quand on transforme cet arbre ans un fichier
textuel.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{fout\_sep (attribut StrategyTree.StrategyTree)@\spxentry{fout\_sep}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.fout_sep}}\pysigline{\sphinxbfcode{\sphinxupquote{fout\_sep}}}
Un séparateur des attributs qu’on utilise quand on transforme cet arbre dans un fichier textuel.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_str\_\_() (méthode StrategyTree.StrategyTree)@\spxentry{\_\_str\_\_()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
Une méthode qui réalise transformation de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Une représentation de l’arbre de stratégie en forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_edge() (méthode StrategyTree.StrategyTree)@\spxentry{add\_edge()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.add_edge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_edge}}}{\emph{parent}, \emph{child}, \emph{child\_type=None}}{}
Une méthode qui permet d’ajouter un arc dans un arbre entre deux noeuds.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Un noeud qui doit être un parent dans cet arc, donc un noeud duquel cet arc part.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Un noeud qui doit être un enfant dans cet arc, donc un noeud auquel cet arc entre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un attribut de la branche du parent à laquelle il faut ajouter un enfant (par exemple si parent est une
observation alors child\_type est égal soit à “no”, soit à “yes”).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_node() (méthode StrategyTree.StrategyTree)@\spxentry{add\_node()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{node}}{}
Une méthode qui permet d’ajouter un.des nouveau.x noeud.s dans l’arbre.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{NodeST / list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Noeud.s à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{connect() (méthode StrategyTree.StrategyTree)@\spxentry{connect()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.connect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connect}}}{\emph{root\_with\_subtree}, \emph{root\_child\_type=None}}{}
Une méthode qui nous permet de connecter deux arbre, plus précisément, on connecte tout cet arbre avec celui
soumis dans root\_with\_subtree en remplissant sa branche qui correspond à root\_child\_type.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_with\_subtree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree}}}}}) \textendash{} Un arbre vers la racine duquel on va connecter cet arbre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_child\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un attribut de la branche de la racine du root\_with\_subtree.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{merged\_tree} \textendash{} Un arbre fusionné.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.StrategyTree)@\spxentry{copy()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Une méthode qui retourne une copie superficielle de cet arbre.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Une copie superficielle de cet arbre\sphinxhyphen{}là.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_adj\_dict() (méthode StrategyTree.StrategyTree)@\spxentry{get\_adj\_dict()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_adj_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_adj\_dict}}}{}{}
Un getter d’un attribut \sphinxstyleemphasis{\_adj\_dict}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_adj\_dict} \textendash{} Une copie superficielle d’un dictionnaire d’adjacence.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_edges() (méthode StrategyTree.StrategyTree)@\spxentry{get\_edges()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_edges}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_edges}}}{}{}
Une méthode qui récupère tous les arcs de l’arbres.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{edges} \textendash{} Une liste de triplets où chaque celui edge correspond à un arc d’un graphe de manière que edge{[}0{]} est un
parent, edge{[}1{]} est un enfant tandis que edge{[}2{]} est un attribut de la branche.

\item[{Type renvoyé}] \leavevmode
list(tuple({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, str))

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_node() (méthode StrategyTree.StrategyTree)@\spxentry{get\_node()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_node}}}{\emph{id}}{}
Une méthode qui retourne un noeud exacte (en sens de l’objet dans mémoire vivant) de l’arbre avec id indiqué.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Soit id de noeud, soit un noeud lui\sphinxhyphen{}même dont un clone (en sens d’id) il faut trouver dans l’arbre.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{n} \textendash{} Un noeud de l’arbre avec la même id que celui soumis.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_node\_by\_name() (méthode StrategyTree.StrategyTree)@\spxentry{get\_node\_by\_name()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_node_by_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_node\_by\_name}}}{\emph{name}}{}
Une méthode qui retourne tous les noeuds de l’arbre dont les noms sont égaux à celui indiqué.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un nom ou un noeud dont le nom on doit utiliser.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{nodes} \textendash{} Une liste de tous les noeuds de l’arbre qui ont le même nom que celui donné.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nodes() (méthode StrategyTree.StrategyTree)@\spxentry{get\_nodes()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_nodes}}}{}{}
Un getter d’un attribut \sphinxstyleemphasis{\_nodes}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_nodes} \textendash{} Une copie superficielle d’une liste des noeuds d’un arbre.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parent() (méthode StrategyTree.StrategyTree)@\spxentry{get\_parent()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_parent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_parent}}}{\emph{child}}{}
Une méthode qui cherche et qui retourne un parent d’un noeud soumis dans l’arbre. Remarque : dans un arbre comme
ça chaque noeud ne doit avoir qu’un seul parent.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Un enfant dont le parent il faut trouver dans cet arbre\sphinxhyphen{}là.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{parent} \textendash{} Un parent trouvé d’un noeud soumis.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_root() (méthode StrategyTree.StrategyTree)@\spxentry{get\_root()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_root}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_root}}}{}{}
Un getter d’un attribut \sphinxstyleemphasis{\_root}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_root} \textendash{} Une racine de l’arbre.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sub\_tree() (méthode StrategyTree.StrategyTree)@\spxentry{get\_sub\_tree()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_sub_tree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sub\_tree}}}{\emph{sub\_root}}{}
Une méthode qui retourne un sous\sphinxhyphen{}arbre de cet arbre\sphinxhyphen{}là étant donné une sous\sphinxhyphen{}racine à partir de laquelle ce
sous\sphinxhyphen{}arbre commence.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sub\_root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Une sous\sphinxhyphen{}racine de l’arbre qui est une racine de sous\sphinxhyphen{}arbre qu’il faut retourner.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{sub\_tree} \textendash{} Un sous\sphinxhyphen{}arbre de cet arbre dont la racine est sub\_root.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_sub\_tree() (méthode StrategyTree.StrategyTree)@\spxentry{remove\_sub\_tree()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.remove_sub_tree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_sub\_tree}}}{\emph{sub\_root}}{}
Une méthode qui nous permet de supprimer un sous\sphinxhyphen{}arbre de cet arbre étant donné une sous\sphinxhyphen{}racine.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sub\_root}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Une sous\sphinxhyphen{}racine d’un sous\sphinxhyphen{}arbre qu’il faut supprimer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{flag} \textendash{} Une variable booléen qui est égale à True si on supprime quelque chose et False sinon.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_root() (méthode StrategyTree.StrategyTree)@\spxentry{set\_root()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.set_root}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_root}}}{\emph{root}}{}
Un setter d’un attribut \sphinxstyleemphasis{\_root}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Une racine à mettre en place.

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_alt() (méthode StrategyTree.StrategyTree)@\spxentry{str\_alt()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.str_alt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{str\_alt}}}{}{}
Une méthode qui réalise une transformation particulière de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Une représentation de l’arbre de stratégie en forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_alt\_2() (méthode StrategyTree.StrategyTree)@\spxentry{str\_alt\_2()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.str_alt_2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{str\_alt\_2}}}{}{}
Une autre méthode qui réalise une transformation particulière de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Une représentation de l’arbre de stratégie en forme de str de manière alternative.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_file() (méthode StrategyTree.StrategyTree)@\spxentry{to\_file()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.to_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_file}}}{\emph{filemame=\textquotesingle{}last\_best\_tree.txt\textquotesingle{}}}{}
Une méthode qui permet de sauvegarder cet arbre de stratégie sous en forme de fichier textuel. On y utilise le
modèle suivant :
\begin{quote}

1) chaque noeud est représenté par une ligne dévouée : \_id,\_cost,\_name,\_type ; c’est bien possible de
remplacer une virgule “,” par un séparateur différent en précisant un attribut self.fout\_sep de
cette classe ;
2) chaque arc est représenté par une ligne dévouée : \_id\_parent,\_id\_child,\_attribut ; où \_attribut est le
type d’arc pour cet arbre\sphinxhyphen{}là (par exemple “yes” ou “no” si parent est une Observation) ;
3) le fichier lui\sphinxhyphen{}même a la structure suivante :
racine de l’arbre    \# ligne 1
{[}ligne vide{]}         \# ligne 2
noeud\_1              \# ligne 3
noeud\_2              \# ligne 4
…
noeud\_n              \# ligne n + 2
{[}ligne vide{]}         \# ligne n + 3
arc\_1                \# ligne n + 4
arc\_2                \# ligne n + 5
…
arc\_m                \# ligne n + m + 3
\end{quote}

Cette méthode utilise également un attribut self.fout\_newline pour représenter une signe qui indique le début
d’une nouvelle ligne.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filemame}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom de fichier où il faut sauvegarder l’arbre concerné.

\end{description}\end{quote}

\end{fulllineitems}

\index{visualize() (méthode StrategyTree.StrategyTree)@\spxentry{visualize()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.visualize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{visualize}}}{\emph{filename=\textquotesingle{}last\_best\_strategy\_tree.gv\textquotesingle{}}}{}
Une méthode qui nous permet d’afficher cet arbre de stratégie via un module graphviz. L’image construit est
sauvegardé dans un fichier “filename.pdf”.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom de fichier où il faut sauvegarder une image obtenue.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{st\_from\_file() (dans le module StrategyTree)@\spxentry{st\_from\_file()}\spxextra{dans le module StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.st_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{st\_from\_file}}}{\emph{filename=\textquotesingle{}last\_best\_tree.txt\textquotesingle{}}, \emph{sep=\textquotesingle{}}, \emph{\textquotesingle{}}, \emph{newline=None}}{}
Une méthode statique du module qui permet de créer un objet du type StrategyTree à partir du fichier qui suit un
modèle fourni par la méthode StrategyTree.to\_file.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un nom du fichier où on stocke l’arbre sous en forme textuelle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un séparateur utilisé dans le fichier passé.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{newline}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Une signe qui indique le début d’une nouvelle ligne.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{stin} \textendash{} Un arbre créé à partir des paramètres passés.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Index des modules Python}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{DecisionTheoreticTroubleshooting}\sphinxstyleindexpageref{index:\detokenize{module-DecisionTheoreticTroubleshooting}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{StrategyTree}\sphinxstyleindexpageref{index:\detokenize{module-StrategyTree}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}