%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsfrench{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Decision Theoretic Troubleshooting}
\date{juin 05, 2020}
\release{}
\author{Ariana Carnielli, Ivan Kachaikin}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\phantomsection\label{\detokenize{index:module-DecisionTheoreticTroubleshooting}}\index{DecisionTheoreticTroubleshooting (module)@\spxentry{DecisionTheoreticTroubleshooting}\spxextra{module}}\index{TroubleShootingProblem (classe dans DecisionTheoreticTroubleshooting)@\spxentry{TroubleShootingProblem}\spxextra{classe dans DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{TroubleShootingProblem}}}{\emph{bayesian\_network}, \emph{costs}, \emph{nodes\_types}}{}
Classe créée pour représenter un problème de Troubleshooting.
Contient des méthodes divers pour résoudre le problème.
Utilise le module pyAgrum pour manipuler le réseau bayesien utilisé pour
répresenter le problème.
Les noeuds du réseau bayésien sont réferencés par des strings.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bayesian\_network}} (\sphinxstyleliteralemphasis{\sphinxupquote{pyAgrum.BayesNet}}) \textendash{} Représente le réseau bayésien (BN) modélisant un problème donné.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Liste avec deux dictionnaires, le premier avec les coûts de
réparation (exactes ou avec des minimun/maximun) et le deuxième
avec les coûts d’observation des noeuds.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes\_types}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire où les clés représent les noeuds du BN
et les valeurs leurs types associés (set de string).

\end{itemize}

\end{description}\end{quote}
\index{bayesian\_network (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{bayesian\_network}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.bayesian_network}}\pysigline{\sphinxbfcode{\sphinxupquote{bayesian\_network}}}
Représente le réseau bayésien (BN) qui modélise un problème donné.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pyAgrum.BayesNet

\end{description}\end{quote}

\end{fulllineitems}

\index{bay\_lp (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{bay\_lp}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.bay_lp}}\pysigline{\sphinxbfcode{\sphinxupquote{bay\_lp}}}
Fait l’inference exacte pour le BN passé en argument.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
pyAgrum.LazyPropagation

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_rep (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_rep}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_rep}}}
Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts de reparation (float).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_rep\_interval (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_rep\_interval}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep_interval}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_rep\_interval}}}
Dictionnaire de coûts où les clés représentent les
noeuds du BN et les valeurs des listes avec les coûts minimum et
maximum de reparation (floats).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{costs\_obs (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{costs\_obs}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_obs}}\pysigline{\sphinxbfcode{\sphinxupquote{costs\_obs}}}
Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts d’observation (float).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{repairable\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{repairable\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.repairable_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{repairable\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments du
système concerné qui peuvent être réparés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{unrepairable\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{unrepairable\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.unrepairable_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{unrepairable\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments
d’un système qui ne peuvent pas être réparés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{problem\_defining\_node (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{problem\_defining\_node}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.problem_defining_node}}\pysigline{\sphinxbfcode{\sphinxupquote{problem\_defining\_node}}}
Noeud qui répresent le problème a être reglé
(système fonctionnel où pas).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{observation\_nodes (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{observation\_nodes}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{observation\_nodes}}}
Ensemble de noeuds qui correspondent aux éléments
du système qui peuvent être observés.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{service\_node (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{service\_node}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.service_node}}\pysigline{\sphinxbfcode{\sphinxupquote{service\_node}}}
Noeud qui répresent l’appel au service (appel à la
réparation sûre du système).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{evidences (attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{evidences}\spxextra{attribut DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.evidences}}\pysigline{\sphinxbfcode{\sphinxupquote{evidences}}}
Dictionnaire ou les clés répresentent les élements du
système qui ont des evidences modifiés dans bay\_lp (donc qui ont
été réparés/observés) et les valeurs sont les inferences faites.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{ECR\_ECO\_wrapper() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{ECR\_ECO\_wrapper()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.ECR_ECO_wrapper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ECR\_ECO\_wrapper}}}{\emph{debug=False}}{}
Calcule l’ECR myope pour chaque prochaine « observation\sphinxhyphen{}réparation »
possible et l’ECO pour chaque prochaine observation globale possible.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{chosen\_node} (\sphinxstyleemphasis{string}) \textendash{} Noeud choisi.

\item {} 
\sphinxstylestrong{type\_node} (\sphinxstyleemphasis{string}) \textendash{} Type du noeud choisi (« repair » ou « obs »).

\item {} 
\sphinxstylestrong{list\_ecr} (\sphinxstyleemphasis{list(tuple)}) \textendash{} ECRs des noeuds d“« observation\sphinxhyphen{}réparation ».

\item {} 
\sphinxstylestrong{list\_eco} (\sphinxstyleemphasis{list(tuple)}) \textendash{} ECOs des noeuds d’observation globale.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_compute\_costs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_compute\_costs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._compute_costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_compute\_costs}}}{\emph{costs}}{}
Prend en argument un dictionnaire de couts qui peut avoir des valeurs
exactes ou des intervalles de valeurs (de la forme {[}minimum, maximum{]})
et le transforme en 2 dictionnaires, un avec les esperances de cout
pour chaque clé et l’autre avec des intervalles de valeurs pour chaque
clé.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de couts où les clés représentent les noeuds
du BN et les valeurs sont de nombres ou de listes de deux
nombres.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{expected\_cost} (\sphinxstyleemphasis{dict}) \textendash{} Dictionnaire où les clés représentent les noeuds du
BN et les valeurs l’esperance de cout de ce noeud. Si la valeur
initiale était déjà un nombre, ce nombre est seulement copié,
sinon on considère que la valeur est une variable aléatoire
avec une distribution uniforme dans l’intervalle et donc
l’esperance est la moyenne des extremités de l’intervalle.

\item {} 
\sphinxstylestrong{interval\_cost} (\sphinxstyleemphasis{dict}) \textendash{} Dictionnaire où les clés représentent les noeuds du
BN et les valeurs sont des listes contenant les deux extremités
des intervalles dans lequels les couts se trouvent. Si la
valeur initiale était déjà un nombre, ce nombre est copié comme
les deux extremités. Si la valeur initiale était un iterable,
on le transforme en liste.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_create\_nodes() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_create\_nodes()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._create_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_create\_nodes}}}{\emph{names}, \emph{rep\_string=\textquotesingle{}\_repair\textquotesingle{}}, \emph{obs\_string=\textquotesingle{}\_observation\textquotesingle{}}, \emph{obs\_rep\_couples=False}}{}
Crée des noeuds de StrategyTree à partir de leurs noms dans le réseau
Bayésien.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{names}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Noms des noeuds de réparations/observations/
observations\sphinxhyphen{}réparations dans le réseau Bayésien à partir desquels
on crée les noeuds.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rep\_string}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dans le cas où on ne considère pas des couples, on utilise ce
paramètre comme un suffixe pour les noeuds de réparation pour les
séparer de ceux d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_string}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Suffixe pour les noeuds d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Variable boléenne qui indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{nodes} \textendash{} Liste de noeuds crées.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{\_evaluate\_all\_st() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_evaluate\_all\_st()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._evaluate_all_st}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_evaluate\_all\_st}}}{\emph{feasible\_nodes}, \emph{obs\_next\_nodes=None}, \emph{parent=None}, \emph{fn\_immutable=None}, \emph{debug\_nb\_call=0}, \emph{debug\_iter=False}, \emph{debug\_st=False}, \emph{obs\_rep\_couples=False}, \emph{obs\_obsolete=False}, \emph{sock=None}}{}
Méthode récursive qui trouve le meilleur arbre de stratégie étant donné
une configuration du problème en dénombrant tous les arbres
admissibles.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feasible\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Lisste des noeuds admissibles qu’on a le droit d’utiliser pour
construire l’arbre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_next\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Pile des attributs des arcs qui partent des noeuds déjà utilisés.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} StrategyTree.StrategyTree)), facultatif
Pile des \sphinxstyleemphasis{parents} vers lesquels il faudra se retourner quand on
remplit entièrement la branche courante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fn\_immutable}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Pile des noeuds admissibles qu’on peut utiliser pour les branches
différentes qui suivent un noeud d’observation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_nb\_call}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Profondeur de la récursivité.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher l’index de l’itération de l’appel.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_st}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Précise s’il faut afficher tous les arbres intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie soumis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. qu’une observation devient obsolète en réparant une
composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_expected\_cost\_of\_repair\_internal() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_expected\_cost\_of\_repair\_internal()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._expected_cost_of_repair_internal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_expected\_cost\_of\_repair\_internal}}}{\emph{strategy\_tree}, \emph{evid\_init=None}, \emph{prob=1.0}, \emph{obs\_obsolete=False}}{}
Partie récursive de la fonction expected\_cost\_of\_repair.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}) \textendash{} Arbre de stratégie dont le coût il faut calculer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evid\_init}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str: str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire d’évidences utilisé dans les appels récursifs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Probabilité initiale.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, on remet en cause les noeuds d’observation globale après
une réparation.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation d’un arbre de stratégie fourni.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_next\_node\_id() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_next\_node\_id()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._next_node_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_next\_node\_id}}}{}{}
Permet d’obtenir la prochaine valeur de \sphinxstyleemphasis{id} pour un noeud de
StrategyTree à partir des ids qu’on utilise déjà stockés dans
\sphinxstyleemphasis{self.\_nodes\_ids\_db\_brute\_force}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{next\_id} \textendash{} Prochain id qu’on peut utiliser avec garantie qu’il n’existe pas de
noeuds déjà avec le même id dans l’arbre de stratégie courant.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_start\_bay\_lp() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{\_start\_bay\_lp()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem._start_bay_lp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_start\_bay\_lp}}}{}{}
Ajoute des inférences vides aux noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés).Ces évidences ne changent pas les
probabilités, elles servent pour qu’on puisse utiliser la méthode
chgEvidence de pyAgrum à la suite.

\end{fulllineitems}

\index{add\_evidence() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{add\_evidence()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.add_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_evidence}}}{\emph{node}, \emph{evidence}}{}
Fonction wrapper pour la fonction chgEvidence de l’objet bay\_lp du
type pyAgrum.LazyPropagation qui additionne une inference et mantient
le dictionnaire evidences actualisé. L’evidence passé en argument ne
doit pas être une evidence « vide » (des 1, utilisé plutôt la fonction
remove\_evidence).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp qui va être modifié.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} \textendash{} Nouvelle inference pour le noeud traité (généralement
une string ici, cf. les types acceptés par chgEvidence)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{best\_EVOI() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{best\_EVOI()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.best_EVOI}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{best\_EVOI}}}{}{}
Détermine la composante qui a la plus grande valeur espérée
d’information (EVOI) correspondant à avoir plus d’information sur
l’intervalle de valeur de son cout.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
Le nom du noeud de réparation avec la plus grande EVOI et la valeur
d’EVOI correspondante.

\item[{Type renvoyé}] \leavevmode
tuple(string, float)

\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver}}}{\emph{debug=False}, \emph{mode=\textquotesingle{}all\textquotesingle{}}, \emph{obs\_rep\_couples=False}, \emph{obs\_obsolete=False}, \emph{sock=None}}{}
Wrapper des différents algorithmes de recherche exhaustive qui calcule
la solution exacte optimale étand donné un problème de Troubleshooting.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool / tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher les résultats intermédiaires du calcul.
Un tuple avec len(tuple) == 2 ou un booléean (équivalent au cas où
on passe un tuple avec deux valeurs identiques). Le premier
composant indique s’il faut afficher l’index de l’itération tandis
que le deuxième précise s’il faut afficher tous les arbres
intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Mode de calcul : soit “dp” pour la programmation dynamique, soit
“all” pour le dénombrement complet.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose des couples « observation\sphinxhyphen{}réparation  » dans
l’arbre de stratégie.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. si c’est possible qu’une observation devient obsolète en
réparant une composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{best\_st} (\sphinxstyleemphasis{StrategyTree.StrategyTree}) \textendash{} Le meilleur arbre de stratégie trouvé.

\item {} 
\sphinxstylestrong{best\_ecr} (\sphinxstyleemphasis{float}) \textendash{} Le coût espéré de réparation du meilleur arbre trouvé i.e.
ECR(\sphinxstyleemphasis{best\_st}).

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver\_actions\_only() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver\_actions\_only()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_actions_only}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver\_actions\_only}}}{\emph{debug=False}}{}
Cherche une séquence optimale de réparation par une recherche
exhaustive en choisissant la séquence de meilleur ECR. Pour le cas où
on ne considère que les actions de réparation il suffit de dénombrer
toutes les permutations possibles d’un ensemble des actions
admissibles.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{min\_seq} (\sphinxstyleemphasis{list(str)}) \textendash{} Séquence optimale trouvée dont le coût est le plus petit possible.

\item {} 
\sphinxstylestrong{min\_ecr} (\sphinxstyleemphasis{float}) \textendash{} Coût espéré de réparation correspondant à min\_seq.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_force\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{brute\_force\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brute\_force\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{strategy\_tree=None}, \emph{mode=\textquotesingle{}dp\textquotesingle{}}, \emph{obs\_rep\_couples=False}, \emph{true\_prices\_obs=None}}{}
Test empirique de la méthode brute\_force\_solver, ou bien de l’arbre de
stratégie obtenu par l’algorithme. Le mécanisme selon lequel on teste
la stratégie est exactement le même que celui utilisé au\sphinxhyphen{}dessus
dans les autres testers.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Arbre de stratégie qu’il faut tester ; si rien passé, on calcule
l’arbre avec la méthode brute\_force\_solver.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Paramètre à passer à la méthode brute\_force\_solver si on doit
l’exécuter. Peut être égal à “all” pour le dénombrement complet ou
“dp” pour la programmation dynamique.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Paramètre à passer à la méthode brute\_force\_solver si on doit
l’exécuter. Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire de prix d’observations des composantes observables.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_EVOIs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{compute\_EVOIs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.compute_EVOIs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_EVOIs}}}{}{}
Calcule les valeurs espérées d’information (EVOIs) correspondant à
avoir plus d’information sur l’intervalle de valeur des couts de
réparation pour chaque composante réparable.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{evoi} \textendash{} Dictionnaire indexé par les noeuds réparables contenant la valeur
d’une information plus précise du cout de réparation de ces noeuds.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{draw\_true\_prices() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{draw\_true\_prices()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.draw_true_prices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{draw\_true\_prices}}}{}{}
Tire au hasard des prix de réparation selon des lois uniformes sur les
intervalles stockés dans self.costs\_rep\_interval.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
Dictionnaire avec prix de réparation.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{dynamic\_programming\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{dynamic\_programming\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.dynamic_programming_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dynamic\_programming\_solver}}}{\emph{feasible\_nodes=None}, \emph{evidence=None}, \emph{debug\_iter=False}, \emph{debug\_st=False}, \emph{obs\_rep\_couples=False}, \emph{prob=1.0}, \emph{obs\_obsolete=False}, \emph{sock=None}, \emph{debug\_nb\_call=0}}{}
Méthode récursive qui trouve le meilleur arbre de stratégie étant donné
une configuration du problème en utilisant comme approche la
programmation dynamique, supposant qu’un sous\sphinxhyphen{}arbre de l’arbre optimal
est lui\sphinxhyphen{}même également optimal.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feasible\_nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Liste des noeuds admissibles qu’on a le droit d’utiliser pour
construire l’arbre.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evidence}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire des évidences initiales pour un appel de cette
fonction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique s’il faut afficher l””index de l’itération dans l’appel.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_st}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Précise s’il faut afficher tous les arbres intermédiaires.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose l’existance de couples
« observation\sphinxhyphen{}réparation » dans l’arbre de stratégie soumis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prob}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Probabilité que le système ne marche toujours pas.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si on suppose la possibilité des « observations obsolètes »,
i.e. qu’une observation devient obsolète en réparant une
composante.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sock}} (\sphinxstyleliteralemphasis{\sphinxupquote{socket.socket}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Socket de communication entre le processus qui effectue le calcul
et celui qui met à jour l’interface. Paramètre nécessaire pour que
le ProgressBar de l’interface marche proprement.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug\_nb\_call}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Profondeur de la récursivité.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{elicitation() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{elicitation()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{elicitation}}}{\emph{noeud}, \emph{islower}}{}
Met à jour l’intervalle de valeurs de cout pour le noeud et son
espérance en fonction de la réponse de l’utilisateur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noeud}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud à mettre à jour.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{islower}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Représente la réponse à la question : Est\sphinxhyphen{}ce que le cout est plus
petit que l’espérance courante ?

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{elicitation\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{elicitation\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{elicitation\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{debug=False}}{}
Test empirique de la résolution avec élicitation. À chaque fois qu’on
doit prendre une action, on vérifie d’abord s’il y a des questions à
répondre et, si oui, on les répond toutes correctement selon
true\_prices. Ensuite, la méthode calcule la séquence d’actions
itérativement à l’aide de myopic\_solver et réalise au plus nb\_max
repetitions d’un système tiré au hasard, le tirage au hasard étant
identique à celui de myopic\_solver\_tester. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\item {} 
\sphinxstylestrong{cpt\_questions} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de questions répondues à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{expected\_cost\_of\_repair() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{expected\_cost\_of\_repair()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{expected\_cost\_of\_repair}}}{\emph{strategy\_tree}, \emph{obs\_obsolete=False}}{}
Calcule le coût espéré de réparation étant donné un arbre de décision.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{strategy\_tree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}) \textendash{} Arbre de stratégie dont le coût il faut calculer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obsolete}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, on remet en cause les noeuds d’observation globale après
une réparation.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation d’un arbre de stratégie fourni.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{expected\_cost\_of\_repair\_seq\_of\_actions() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{expected\_cost\_of\_repair\_seq\_of\_actions()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair_seq_of_actions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{expected\_cost\_of\_repair\_seq\_of\_actions}}}{\emph{seq}}{}
Calcule le coût espéré de réparation à partir d’une séquence d’actions
donnée. On utilise la formule
ECR = coût(C1 | E0)
+ P(C1 = Normal | E0) * coût(C2 | E1)
+ P(C1 = Normal | E0) * P(C2 = Normal | E1) * coût(C2 | E2)
+ …
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{seq}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Séquence d’actions de réparations dont le coût espéré est à
calculer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ecr} \textendash{} Coût espéré de réparation de la séquence donnée.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_proba() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{get\_proba()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.get_proba}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_proba}}}{\emph{node}, \emph{value}}{}
Récupère à partir du réseau bayésien la probabilité que le noeud node
ait la valeur value.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp dont on veut calculer la probabilité.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Valeur du noeud dont on veut calculer la probabilité.

\end{itemize}

\item[{Renvoie}] \leavevmode
La probabilité P(node = value)

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver}}}{\emph{debug=False}, \emph{esp\_obs=False}}{}
Implémente une étape du solveur myope. Étant donné l’état actuel du
réseau, ce solveur utilise dans un premier temps le simple\_solver\_obs
pour déterminer quelle action du type « observation\sphinxhyphen{}réparation » serait
la meilleure. Ensuite, il calcule les coûts myopes espérés avec chaque
observation possible et choisit à la fin la meilleure action à être
prise.

Cette fonction est itérative et ne fait qu’un seul tour de
l’algorithme myope car elle attend des nouvelles informations venues
de l’utilisateur (résultat de l’observation si c’est le cas).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{esp\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, retourne en plus un dictionnaire indexé par les
observations possibles et contenants leurs couts myopes espérés
respectifs.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{chosen\_node} (\sphinxstyleemphasis{string}) \textendash{} Le meilleur noeud de ce tour

\item {} 
\sphinxstylestrong{type\_node} (\sphinxstyleemphasis{string}) \textendash{} Type du meilleur noeud (« repair » ou « obs »)

\item {} 
\sphinxstylestrong{eco} (\sphinxstyleemphasis{dict}) \textendash{} Retourné uniquement lorsque esp\_obs vaut True. Dictionnaire des
couts espérés des observations.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver\_st() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver\_st()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_st}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver\_st}}}{\emph{evid\_init=None}}{}
Une méthode qui récupère un arbre de stratégie qu’on peut construire à partir de myopic\_solver.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{evid\_init}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Un dictionnaire des évidences par défaut.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{strat\_tree} \textendash{} Un arbre de stratégie qu’on construit utilisant pas\sphinxhyphen{}à\sphinxhyphen{}pas une méthode myopic\_solver en remplissant cet arbre
en largeur.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree.StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}, \emph{debug=False}}{}
Test empirique de la méthode myopic\_solver. Cette méthode calcule
la séquence d’actions itérativement à l’aide de myopic\_solver et
réalise au plus nb\_max repetitions d’un système tiré au hasard. À
chaque observation globale, son résultat est tiré au hasard. Pour les
paires « observation\sphinxhyphen{}réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\item {} 
\sphinxstylestrong{cpt\_obs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre d’observations globales faites à chaque
répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{myopic\_wraper() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{myopic\_wraper()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_wraper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{myopic\_wraper}}}{\emph{debug=False}}{}
Interface textuelle pour le solveur myope. Utilise myopic\_solver à
chaque tour de boucle pour déterminer la meilleure action à prendre.
Si c’est une observation, le résultat de l’observation est demandé,
sinon on demande juste si l’action a résolu le problème. Les
élicitations de couts ne sont pas implémentées. Les entrées de
l’utilisateur ne sont pas sécurisées.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\end{description}\end{quote}

\end{fulllineitems}

\index{noeud\_ant() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{noeud\_ant()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.noeud_ant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{noeud\_ant}}}{\emph{node}, \emph{visites}}{}
Détermine tous les noeuds d’observation impactés par un changement
du noeud node et qui sont antécesseurs de node, sans visiter les noeuds
déjà dans l’ensemble des visites. Cette fonction est auxiliaire et n’a
pas vocation à être appellée en dehors de la fonction principale
observation\_obsolete.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud don l’information a changé.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visites}} (\sphinxstyleliteralemphasis{\sphinxupquote{set}}) \textendash{} Contient les noeuds déjà visités.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{ant\_obs} \textendash{} Ensemble des noeuds d’observation affectés par node et qui sont
antecesseurs de node sans être dans visites.

\item[{Type renvoyé}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{observation\_obsolete() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{observation\_obsolete()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_obsolete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{observation\_obsolete}}}{\emph{node}}{}
Étant donné un noeud dont l’information a changé, on détermine, à
partir du réseau bayésien, tous les noeuds d’observation impactés par
ce chagement.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud dont l’information a changé.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{obs} \textendash{} Ensemble contenant les noeuds d’observation impactés.

\item[{Type renvoyé}] \leavevmode
set

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_evidence() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{remove\_evidence()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.remove_evidence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_evidence}}}{\emph{node}}{}
Fonction wrapper pour la fonction chgEvidence de l’objet bay\_lp du
type pyAgrum.LazyPropagation qui retire une inference et mantient le
dictionnaire evidences actualisé.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Nom du noeud de bay\_lp qui va être modifié.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_bay\_lp() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{reset\_bay\_lp()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.reset_bay_lp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_bay\_lp}}}{\emph{dict\_inf=\{\}}}{}
Reinitialise les inférences des noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés). Pour les noeuds dans dict\_inf, l’inférence
est mis à la valeur associé au noeud dans dict\_inf, pour les autres
l’inférence est mis à 1.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{dict\_inf}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Dictionnaire où les clés sont des noeuds et les valeurs sont des
inférences.

\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver}}}{\emph{debug=False}}{}
Solveur simple pour le problème du TroubleShooting.
On ne prend pas en considèration des observations et on ne révise pas
les probabilités, c’est\sphinxhyphen{}à\sphinxhyphen{}dire on ne met pas à jour les probabilités
si on répare une composante.
À cause de cela, ce solveur n’est pas iteractif et renvoie l’ordre de
réparation entière (jusqu’au appel au service).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rep\_seq} (\sphinxstyleemphasis{list}) \textendash{} Séquence des noeuds à être réparés dans l’ordre.

\item {} 
\sphinxstylestrong{exp\_cost} (\sphinxstyleemphasis{float}) \textendash{} Espérance du coût de réparation de cette séquence.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_obs() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_obs()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_obs}}}{\emph{debug=False}}{}
Solveur simple pour le problème du Troubleshooting.
On prend en considèration des paires « observation\sphinxhyphen{}réparation » (cf.
définition dans l’état de l’art) mais pas les observations globales
et on révise les probabilités, c’est\sphinxhyphen{}à\sphinxhyphen{}dire on met à jour les
probabilités quand on « répare » une composante avant de calculer le
prochaine composante de la séquence.

Le solveur n’est pas encore iteractif et renvoie l’ordre de réparation
entière (jusqu’au appel au service). Cette choix à été fait car on
utilise cet algorithme comme part de l’agorithme plus complexe et
iteratif.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Si True, affiche des messages montrant le déroulement de
l’algorithme.

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rep\_seq} (\sphinxstyleemphasis{list}) \textendash{} Séquence des noeuds à être réparés dans l’ordre.

\item {} 
\sphinxstylestrong{exp\_cost} (\sphinxstyleemphasis{float}) \textendash{} Espérance du coût de réparation de cette séquence.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_obs\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_obs\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_obs\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}}{}
Test empirique de la méthode simple\_solver\_obs. Cette méthode calcule
la séquence d’actions à l’aide de simple\_solver\_obs et réalise au plus
nb\_max répétitions d’un système tiré au hasard : si on a une paire
« observation\sphinxhyphen{}réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb\_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true\_prices.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_solver\_tester() (méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem)@\spxentry{simple\_solver\_tester()}\spxextra{méthode DecisionTheoreticTroubleshooting.TroubleShootingProblem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_tester}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simple\_solver\_tester}}}{\emph{true\_prices}, \emph{epsilon}, \emph{nb\_min=100}, \emph{nb\_max=200}}{}
Test empirique de la méthode simple\_solver. Cette méthode calcule la
séquence d’actions à l’aide de simple\_solver et réalise au plus nb\_max
repétitions d’un système tiré au hasard : à chaque fois qu’on a une
probabilité qu’une action résoud le problème, on tire au hasard pour
déterminer si le problème a effectivement été résolu ou pas suite à
cette action. Si après nb\_min repétitions l’erreur estimée est plus
petite que epsilon, on fait une sortie anticipée. La fonction calcule
aussi les couts empiriques de réparation, en utilisant pour cela
true\_prices. Cette méthode utilise la single fault assumption.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{true\_prices}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionnaire de prix de réparation des composantes réparables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Tolerance relative de la moyenne.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre minimum de répétitions à être realisées.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nb\_max}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Nombre maximum de répétitions à être realisées.

\end{itemize}

\item[{Renvoie}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sortie\_anti} (\sphinxstyleemphasis{bool}) \textendash{} True en cas de sortie anticipée, False sinon.

\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec les cout associés.

\item {} 
\sphinxstylestrong{mean} (\sphinxstyleemphasis{float}) \textendash{} Moyenne des couts.

\item {} 
\sphinxstylestrong{std} (\sphinxstyleemphasis{float}) \textendash{} Variance des couts.

\item {} 
\sphinxstylestrong{cpt\_repair} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Tableau avec le nombre de composantes réparées à chaque répétition.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{bcolors (classe dans DecisionTheoreticTroubleshooting)@\spxentry{bcolors}\spxextra{classe dans DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.bcolors}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{bcolors}}}
Stockage de couleurs.

\end{fulllineitems}

\index{diff\_dicts() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{diff\_dicts()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.diff_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{diff\_dicts}}}{\emph{left}, \emph{right}}{}
Calcule la différence des dictionnaires \sphinxstyleemphasis{left} et \sphinxstyleemphasis{right} : les entrées de
\sphinxstyleemphasis{left} dont la clé est aussi présente dans \sphinxstyleemphasis{right} sont supprimées, les
autres sont gardées.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{left}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Premier dictionnaire, duquel on supprime les clés apparaissant dans
\sphinxstyleemphasis{right}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Deuxième dictionnaire, celui avec les clés qui doivent être supprimées
de \sphinxstyleemphasis{left}.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{res} \textendash{} Résultat de la différence entre \sphinxstyleemphasis{left} et \sphinxstyleemphasis{right}.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{merge\_dicts() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{merge\_dicts()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.merge_dicts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{merge\_dicts}}}{\emph{left}, \emph{right}}{}
Fusionne deux dictionnaire passés sans les changer. Les couples (clé,
valeur) du dictionnaire \sphinxstyleemphasis{right} sont plus prioritaires que celles de
\sphinxstyleemphasis{left} ; c’est\sphinxhyphen{}à\sphinxhyphen{}dire, s’il existe une valeur associée à la même clé k dans
les deux dictionnaires, on ajoute dans le résultat seulement celle qui
appartient à \sphinxstyleemphasis{right}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{left}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Un des dictionnaires à fusionner, celui qui est moins prioritaire.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} L’autre dictionnaire à fusionner, celui qui est plus prioritaire.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{res} \textendash{} Résultat de la fusion.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{shallow\_copy\_list\_of\_copyable() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{shallow\_copy\_list\_of\_copyable()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.shallow_copy_list_of_copyable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{shallow\_copy\_list\_of\_copyable}}}{\emph{l}}{}
Crée une copie de profondeur 1 de la liste passée en argument : la liste
est recopiée et remplie avec l’appel de la méthode copy() en chaque élément
de la liste donnée.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\textless{}Copyable\textgreater{}}}) \textendash{} La liste qui sera copiée. Chacun de ses éléments doit implémenter la
méthode copy().

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{cl} \textendash{} Copie de profondeur 1 de la liste passée en argument.

\item[{Type renvoyé}] \leavevmode
list\textless{}Copyable\textgreater{}

\end{description}\end{quote}

\end{fulllineitems}

\index{shallow\_copy\_parent() (dans le module DecisionTheoreticTroubleshooting)@\spxentry{shallow\_copy\_parent()}\spxextra{dans le module DecisionTheoreticTroubleshooting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DecisionTheoreticTroubleshooting.shallow_copy_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DecisionTheoreticTroubleshooting.}}\sphinxbfcode{\sphinxupquote{shallow\_copy\_parent}}}{\emph{parent}}{}
Crée une copie superficielle de \sphinxstyleemphasis{parent} (cf la méthode
TroubleShootingProblem.\_evaluate\_all\_st ci\sphinxhyphen{}dessous).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree.StrategyTree}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Parent dont la copie il faut créer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{parent\_copy} \textendash{} Copie superficielle du parent passé.

\item[{Type renvoyé}] \leavevmode
list(tuple({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{StrategyTree.NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree.StrategyTree}}}))

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-StrategyTree}}\index{StrategyTree (module)@\spxentry{StrategyTree}\spxextra{module}}\index{NodeST (classe dans StrategyTree)@\spxentry{NodeST}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{NodeST}}}{\emph{id}, \emph{cost}, \emph{name=None}}{}
Représente un noeud abstrait d’un arbre de stratégie; on remarque que cette
classe ne dispose pas d’attribut correspondant à des enfants (il n’y a pas
un attribut qui correspond à les noeuds suivants), pourtant, on suppose que
ses sous\sphinxhyphen{}classes en auront.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique d’un noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Correspond au « coût » du noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.NodeST)@\spxentry{\_id}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique d’un noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.NodeST)@\spxentry{\_cost}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Correspond au « coût » du noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_name (attribut StrategyTree.NodeST)@\spxentry{\_name}\spxextra{attribut StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST._name}}\pysigline{\sphinxbfcode{\sphinxupquote{\_name}}}
Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (méthode StrategyTree.NodeST)@\spxentry{\_\_eq\_\_()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.__eq__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_eq\_\_}}}{\emph{other}}{}
Overloading de l’opérateur \_\_eq\_\_ ; on dit que deux noeuds sont égaux
ssi ils ont les mêmes ids.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Le noeud à comparer avec le noeud concerné.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{comp\_res} \textendash{} True si self.\_id == other.\_id ET si self et other ont le même type.
False, sinon.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_str\_\_() (méthode StrategyTree.NodeST)@\spxentry{\_\_str\_\_()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
Overloading de l’opérateur \_\_str\_\_.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{corr\_str} \textendash{} La représentation du noeud sous la forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.NodeST)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Méthode abstraite qui ajouterait un enfant au noeud.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} L’enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.NodeST)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Méthode abstraite qui retournera un dictionnaire des associations entre
les labels du réseau Bayésien et les enfants du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Le dictionnaire des associations.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.NodeST)@\spxentry{copy()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Retournerait une copie superficielle du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Copie superficielle du noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.NodeST)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Méthode abstraite qui retournerait l’enfant du noeud correspondant à
\sphinxstyleemphasis{attr}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} L’attribut de l’enfant qu’il faut retourner.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} L’enfant du noeud concerné qui correspond à l’attribut soumis.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_cost() (méthode StrategyTree.NodeST)@\spxentry{get\_cost()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_cost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_cost}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_cost}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_cost} \textendash{} La valeur du coût du noeud concerné.

\item[{Type renvoyé}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_id() (méthode StrategyTree.NodeST)@\spxentry{get\_id()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_id} \textendash{} Identificateur unique courant du noeud concerné.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.NodeST)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Méthode abstraite qui permettrait d’obtenir la liste de tous les
enfants d’un noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} Liste de tous les enfants d’un noeud.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_name() (méthode StrategyTree.NodeST)@\spxentry{get\_name()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.get_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_name}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_name}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_name} \textendash{} Le nom du noeud concerné.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.NodeST)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Méthode abstraite qui ajouterait un enfant correspondant à \sphinxstyleemphasis{attr} aux
enfants du noeud concerné.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} L’attribut (un type) de l’enfant qui va être ajouté.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} L’enfant qu’on veut ajouter. Il faut qu’il correspond à l’attribut
soumis.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cost() (méthode StrategyTree.NodeST)@\spxentry{set\_cost()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_cost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_cost}}}{\emph{cost}}{}
Setter de l’attribut \sphinxstyleemphasis{\_cost}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Valeur du coût du noeud en question. Plus grand ou égal à zero.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_id() (méthode StrategyTree.NodeST)@\spxentry{set\_id()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_id}}}{\emph{id}}{}
Setter de l’attribut \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Nouvel identificateur du noeud en question. Doit être unique.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_name() (méthode StrategyTree.NodeST)@\spxentry{set\_name()}\spxextra{méthode StrategyTree.NodeST}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.NodeST.set_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_name}}}{\emph{name}}{}
Setter de l’attribut \sphinxstyleemphasis{\_name}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Le nouveau nom du noeud en question.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Observation (classe dans StrategyTree)@\spxentry{Observation}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{Observation}}}{\emph{id}, \emph{cost}, \emph{name=None}, \emph{yes\_child=None}, \emph{no\_child=None}, \emph{obs\_rep\_couples=False}}{}
Classe pour répresenter les noeuds des arbres de stratégie correspondants à
des actions d’observation.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique du noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Correspond au « coût » du noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{yes\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant du noeud qui correspond à la branche « yes ».

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{no\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant du noeud qui correspond à la branche « no ».

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Indique si le noeud représente un couple observation\sphinxhyphen{}réparation ou pas.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.Observation)@\spxentry{\_id}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique du noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.Observation)@\spxentry{\_cost}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Correspond au « coût » du noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_name (attribut StrategyTree.Observation)@\spxentry{\_name}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._name}}\pysigline{\sphinxbfcode{\sphinxupquote{\_name}}}
Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, facultatif

\end{description}\end{quote}

\end{fulllineitems}

\index{\_yes\_child (attribut StrategyTree.Observation)@\spxentry{\_yes\_child}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._yes_child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_yes\_child}}}
Enfant du noeud qui correspond à la branche « yes ».
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, facultatif

\end{description}\end{quote}

\end{fulllineitems}

\index{\_no\_child (attribut StrategyTree.Observation)@\spxentry{\_no\_child}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._no_child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_no\_child}}}
Enfant du noeud qui correspond à la branche « no ».
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, facultatif

\end{description}\end{quote}

\end{fulllineitems}

\index{\_obs\_rep\_couples (attribut StrategyTree.Observation)@\spxentry{\_obs\_rep\_couples}\spxextra{attribut StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation._obs_rep_couples}}\pysigline{\sphinxbfcode{\sphinxupquote{\_obs\_rep\_couples}}}
Indique si le noeud représente un couple observation\sphinxhyphen{}réparation ou pas.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool, facultatif

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.Observation)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Ajoute un enfant dans la liste des enfants du noeud.
ATTENTION : ce méthode ne change pas un enfant qui existe déjà; pour
cela, veuillez utiliser set\_child. Par defaut, essaie d’ajouter
l’enfant au branche \_yes\_child d’abord.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} L’enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.Observation)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Retourne un dictionnaire des associations entre les labels d’un réseau
Bayésien et les enfants du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Le dictionnaire des associations concerné.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.Observation)@\spxentry{copy()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Retourne une copie superficielle du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} copie superficielle du noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.Observation}]{\sphinxcrossref{Observation}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.Observation)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Retourne l’enfant du noeud qui correspond à l’attribut passé en
argument, c’est\sphinxhyphen{}à\sphinxhyphen{}dire l’enfant sur branche \_yes\_child si « yes » est
passé en argument et l’enfant sur branche \_no\_child if « no » est passé.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Indique la branche voulue.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} L’enfant correspondant à l’attribut.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.Observation)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Retourne la liste avec tous les enfants du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} Liste avec tous les enfants du noeud.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_no\_child() (méthode StrategyTree.Observation)@\spxentry{get\_no\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_no_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_no\_child}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_no\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_no\_child} \textendash{} Enfant du noeud qui correspond à la branche « no ».

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_obs\_rep\_couples() (méthode StrategyTree.Observation)@\spxentry{get\_obs\_rep\_couples()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_obs_rep_couples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_obs\_rep\_couples}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_obs\_rep\_couples}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_obs\_rep\_couples} \textendash{} Indique si le noeud représente un couple d’observation\sphinxhyphen{}réparation
ou pas.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_yes\_child() (méthode StrategyTree.Observation)@\spxentry{get\_yes\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.get_yes_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_yes\_child}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_yes\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_yes\_child} \textendash{} Enfant du noeud qui correspond à la branche « yes ».

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.Observation)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Met en place l’enfant correspondant à l’attribut de la branche indiqué
par \sphinxstyleemphasis{attr}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Indique la branche voulue.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant qui va être mis en place.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_no\_child() (méthode StrategyTree.Observation)@\spxentry{set\_no\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_no_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_no\_child}}}{\emph{no\_child=None}}{}
Setter de l’attribut \sphinxstyleemphasis{\_no\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{no\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant du noeud qui correspond à la branche « no ».

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_obs\_rep\_couples() (méthode StrategyTree.Observation)@\spxentry{set\_obs\_rep\_couples()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_obs_rep_couples}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_obs\_rep\_couples}}}{\emph{obs\_rep\_couples}}{}
Setter de l’attribut \sphinxstyleemphasis{\_obs\_rep\_couples}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obs\_rep\_couples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Indique si le noeud représente un couple d’observation\sphinxhyphen{}réparation
ou pas.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_yes\_child() (méthode StrategyTree.Observation)@\spxentry{set\_yes\_child()}\spxextra{méthode StrategyTree.Observation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Observation.set_yes_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_yes\_child}}}{\emph{yes\_child=None}}{}
Setter de l’attribut \sphinxstyleemphasis{\_yes\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{yes\_child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant du noeud qui correspond à la branche « yes ».

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Repair (classe dans StrategyTree)@\spxentry{Repair}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{Repair}}}{\emph{id}, \emph{cost}, \emph{name=None}, \emph{child=None}}{}
Classe pour répresenter les noeuds des arbres de stratégie correspondants à
des actions de réparation.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identificateur unique du noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Correspond au « coût » du noeud.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Enfant du noeud, c’est\sphinxhyphen{}à\sphinxhyphen{}dire, le noeud suivant dans un arbre.

\end{itemize}

\end{description}\end{quote}
\index{\_id (attribut StrategyTree.Repair)@\spxentry{\_id}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._id}}\pysigline{\sphinxbfcode{\sphinxupquote{\_id}}}
Identificateur unique du noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_cost (attribut StrategyTree.Repair)@\spxentry{\_cost}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._cost}}\pysigline{\sphinxbfcode{\sphinxupquote{\_cost}}}
Correspond au « coût » du noeud.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{name (attribut StrategyTree.Repair)@\spxentry{name}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}
Nom du noeud qui peut ne pas être unique; si rien a été soumis, on pose
que \sphinxstyleemphasis{\_name} = \sphinxstyleemphasis{\_id}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str, facultatif

\end{description}\end{quote}

\end{fulllineitems}

\index{\_child (attribut StrategyTree.Repair)@\spxentry{\_child}\spxextra{attribut StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair._child}}\pysigline{\sphinxbfcode{\sphinxupquote{\_child}}}
Enfant du noeud, c’est\sphinxhyphen{}à\sphinxhyphen{}dire, le noeud suivant dans un arbre.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_child() (méthode StrategyTree.Repair)@\spxentry{add\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.add_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_child}}}{\emph{child}}{}
Ajoute un enfant dans la liste des enfants du noeud.
ATTENTION : ce méthode ne change pas un enfant qui existe déjà; pour
cela, veuillez utiliser set\_child.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} L’enfant à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{bn\_labels\_children\_association() (méthode StrategyTree.Repair)@\spxentry{bn\_labels\_children\_association()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.bn_labels_children_association}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bn\_labels\_children\_association}}}{}{}
Retourne un dictionnaire des associations entre les labels d’un réseau
Bayésien et les enfants du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{da} \textendash{} Dictionnaire des associations concerné.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.Repair)@\spxentry{copy()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Retourne une copie superficielle du noeud.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Copie superficielle du noeud.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.Repair}]{\sphinxcrossref{Repair}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child() (méthode StrategyTree.Repair)@\spxentry{get\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_child}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_child} \textendash{} L’enfant du noeud concerné.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_child\_by\_attribute() (méthode StrategyTree.Repair)@\spxentry{get\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_child\_by\_attribute}}}{\emph{attr}}{}
Realisation d’une méthode abstraite de la superclass; comme ce type de
noeud ne dispose que d’un seul enfant on retourne toujours cet enfant
pour n’importe quel \sphinxstyleemphasis{attr} passé en argument.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} L’attribut de l’enfant qu’il faut retourner. Peut être n’importe
quoi ici.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{child} \textendash{} L’enfant du noeud concerné.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_list\_of\_children() (méthode StrategyTree.Repair)@\spxentry{get\_list\_of\_children()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.get_list_of_children}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_list\_of\_children}}}{}{}
Retourne la liste qui contient tous les enfants du noeud; pour ce cas,
soit une liste avec un seul élément, soit une liste vide.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{list\_of\_children} \textendash{} La liste de tous les enfants du noeud (ici soit une liste avec un
seul élément, soit une liste vide).

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child() (méthode StrategyTree.Repair)@\spxentry{set\_child()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.set_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child}}}{\emph{child=None}}{}
Setter de l’attribut \sphinxstyleemphasis{\_child}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} L’enfant du noeud.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_child\_by\_attribute() (méthode StrategyTree.Repair)@\spxentry{set\_child\_by\_attribute()}\spxextra{méthode StrategyTree.Repair}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.Repair.set_child_by_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_child\_by\_attribute}}}{\emph{attr}, \emph{child=None}}{}
Realisation d’une méthode abstraite de la superclass qui met en place
un enfant correspondant à \sphinxstyleemphasis{attr} au noeud concerné.
superclass.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attr}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} L’attribut (un type) de l””enfant qu’il faut mettre en place.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} L’enfant qu’on veut ajouter. Il faut qu’il correspond à l’attribut
soumis.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StrategyTree (classe dans StrategyTree)@\spxentry{StrategyTree}\spxextra{classe dans StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{StrategyTree}}}{\emph{root=None}, \emph{nodes=None}}{}
Représente l’arbre de stratégie qui est utilisé à la résolution du problème
de Troubleshooting.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Racine de l’arbre, i.e. une action pour commencer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Liste des noeuds de l’arbre.

\end{itemize}

\end{description}\end{quote}
\index{\_root (attribut StrategyTree.StrategyTree)@\spxentry{\_root}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._root}}\pysigline{\sphinxbfcode{\sphinxupquote{\_root}}}
Racine de l’arbre, i.e. une action pour commencer.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_nodes (attribut StrategyTree.StrategyTree)@\spxentry{\_nodes}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._nodes}}\pysigline{\sphinxbfcode{\sphinxupquote{\_nodes}}}
Liste des noeuds de l’arbre.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{\_adj\_dict (attribut StrategyTree.StrategyTree)@\spxentry{\_adj\_dict}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree._adj_dict}}\pysigline{\sphinxbfcode{\sphinxupquote{\_adj\_dict}}}
Dictionnaire qui indique quels noeuds sont liés par des arcs.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{fout\_newline (attribut StrategyTree.StrategyTree)@\spxentry{fout\_newline}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.fout_newline}}\pysigline{\sphinxbfcode{\sphinxupquote{fout\_newline}}}
Indique le début d’une nouvelle ligne quand on transforme cet arbre en
un fichier de texte.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{fout\_sep (attribut StrategyTree.StrategyTree)@\spxentry{fout\_sep}\spxextra{attribut StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.fout_sep}}\pysigline{\sphinxbfcode{\sphinxupquote{fout\_sep}}}
Séparateur d’attributs qu’on utilise quand on transforme cet arbre en
un fichier texte.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_str\_\_() (méthode StrategyTree.StrategyTree)@\spxentry{\_\_str\_\_()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
Réalise la transformation de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Représentation de l’arbre de stratégie en forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_edge() (méthode StrategyTree.StrategyTree)@\spxentry{add\_edge()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.add_edge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_edge}}}{\emph{parent}, \emph{child}, \emph{child\_type=None}}{}
Permet d’ajouter un arc dans un arbre entre deux noeuds.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parent}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Noeud qui va être le parent. Le noeud duquel l’arc part.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Noeud qui va être l’enfant. Le noeud auquel l’arc arrive.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{child\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} L’attribut de la branche du parent à laquelle il faut ajouter
l’enfant (par exemple si parent est une observation alors
child\_type est égal soit à “no”, soit à “yes”).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_node() (méthode StrategyTree.StrategyTree)@\spxentry{add\_node()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{node}}{}
Permet d’ajouter un ou plusieurs nouveaux noeuds dans l’arbre.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{NodeST / list}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Noeud.s à ajouter.

\end{description}\end{quote}

\end{fulllineitems}

\index{connect() (méthode StrategyTree.StrategyTree)@\spxentry{connect()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.connect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connect}}}{\emph{root\_with\_subtree}, \emph{root\_child\_type=None}}{}
Connecte deux arbres, plus précisément, on connecte l’arbre actuel à
l’arbre \sphinxstyleemphasis{root\_with\_subtree} en remplissant la branche qui correspond à
root\_child\_type dans \sphinxstyleemphasis{root\_with\_subtree}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_with\_subtree}} ({\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StrategyTree}}}}}) \textendash{} L’arbre vers la racine duquel on va connecter l’arbre actuel.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_child\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} L’attribut de la branche de la racine du root\_with\_subtree.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{merged\_tree} \textendash{} L’arbre fusionné.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (méthode StrategyTree.StrategyTree)@\spxentry{copy()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Retourne une copie superficielle de l’arbre.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{copy} \textendash{} Copie superficielle de l’arbre.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_adj\_dict() (méthode StrategyTree.StrategyTree)@\spxentry{get\_adj\_dict()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_adj_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_adj\_dict}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_adj\_dict}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_adj\_dict} \textendash{} Copie superficielle du dictionnaire d’adjacence de l’arbre.

\item[{Type renvoyé}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_edges() (méthode StrategyTree.StrategyTree)@\spxentry{get\_edges()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_edges}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_edges}}}{}{}
Récupère tous les arcs de l’arbre.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{edges} \textendash{} Liste de triplets où chaque élement correspond à un arc d’un graphe
de manière que tuple{[}0{]} est un parent, tuple{[}1{]} est leur enfant et
tuple{[}2{]} est l’attribut identifiant la branche.

\item[{Type renvoyé}] \leavevmode
list(tuple({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, {\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}, str))

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_node() (méthode StrategyTree.StrategyTree)@\spxentry{get\_node()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_node}}}{\emph{id}}{}
Retourne le noeud exacte (en sens de l’objet dans mémoire vivant) de
l’arbre avec \sphinxstyleemphasis{id} indiqué.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Soit \sphinxstyleemphasis{id} du noeud, soit un noeud lui\sphinxhyphen{}même dont on cherche un clone
(en sens d’id) dans l’arbre.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{n} \textendash{} Noeud de l’arbre avec la \sphinxstyleemphasis{id} soumis.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_node\_by\_name() (méthode StrategyTree.StrategyTree)@\spxentry{get\_node\_by\_name()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_node_by_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_node\_by\_name}}}{\emph{name}}{}
Retourne tous les noeuds de l’arbre dont les noms sont égaux à celui
indiqué.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Un nom ou un noeud dont le nom on doit utiliser.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{nodes} \textendash{} Liste de tous les noeuds de l’arbre qui ont le même nom que celui
indiqué.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nodes() (méthode StrategyTree.StrategyTree)@\spxentry{get\_nodes()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_nodes}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_nodes}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_nodes} \textendash{} Copie superficielle de la liste des noeuds de l’arbre.

\item[{Type renvoyé}] \leavevmode
list({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parent() (méthode StrategyTree.StrategyTree)@\spxentry{get\_parent()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_parent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_parent}}}{\emph{child}}{}
Retourne le parent du noeud \sphinxstyleemphasis{child} dans l’arbre. Remarque : dans cette
implémentation d’arbre chaque noeud ne peut avoir qu’un seul parent.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{child}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} L’enfant dont le parent on cherche dans l’arbre.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{parent} \textendash{} Parent du noeud \sphinxstyleemphasis{child}.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_root() (méthode StrategyTree.StrategyTree)@\spxentry{get\_root()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_root}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_root}}}{}{}
Getter de l’attribut \sphinxstyleemphasis{\_root}.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{\_root} \textendash{} Racine de l’arbre.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{NodeST}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sub\_tree() (méthode StrategyTree.StrategyTree)@\spxentry{get\_sub\_tree()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.get_sub_tree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sub\_tree}}}{\emph{sub\_root}}{}
Retourne le sous\sphinxhyphen{}arbre qui a le noeud \sphinxstyleemphasis{sub\_root} comme racine.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sub\_root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Racine de le sous\sphinxhyphen{}arbre.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{sub\_tree} \textendash{} Sous\sphinxhyphen{}arbre de cet arbre dont la racine est \sphinxstyleemphasis{sub\_root}.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_sub\_tree() (méthode StrategyTree.StrategyTree)@\spxentry{remove\_sub\_tree()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.remove_sub_tree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_sub\_tree}}}{\emph{sub\_root}}{}
Supprime le sous\sphinxhyphen{}arbre qui a comme racine \sphinxstyleemphasis{sub\_root}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sub\_root}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / NodeST}}) \textendash{} Racine du sous\sphinxhyphen{}arbre qu’il faut supprimer.

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{flag} \textendash{} Égale à True si la fonction a supprimé un sous\sphinxhyphen{}arbre, False sinon.

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_root() (méthode StrategyTree.StrategyTree)@\spxentry{set\_root()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.set_root}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_root}}}{\emph{root}}{}
Setter de l’attribut \sphinxstyleemphasis{\_root}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{root}} ({\hyperref[\detokenize{index:StrategyTree.NodeST}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NodeST}}}}}) \textendash{} Racine à mettre en place.

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_alt() (méthode StrategyTree.StrategyTree)@\spxentry{str\_alt()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.str_alt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{str\_alt}}}{}{}
Réalise la transformation de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Représentation de l’arbre de stratégie en forme de str.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_alt\_2() (méthode StrategyTree.StrategyTree)@\spxentry{str\_alt\_2()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.str_alt_2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{str\_alt\_2}}}{}{}
Transformation alternative de l’arbre vers str.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
\sphinxstylestrong{st\_str} \textendash{} Représentation de l’arbre de stratégie en forme de str de manière
alternative.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_file() (méthode StrategyTree.StrategyTree)@\spxentry{to\_file()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.to_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_file}}}{\emph{filemame=\textquotesingle{}last\_best\_tree.txt\textquotesingle{}}}{}
Permet de sauvegarder l’arbre de stratégie sous forme de fichier texte.
On utilise le modèle suivant :
1) Chaque noeud est représenté par une ligne du type :
\_id,\_cost,\_name,\_type
C’est bien possible de remplacer la virgule par un séparateur
différent en précisant l’attribut \sphinxstyleemphasis{self.fout\_sep} de la classe.
2) Chaque arc est représenté par une ligne du type :
\_id\_parent,\_id\_child,\_attribut
Où \_attribut est le type d’arc (par exemple “yes” ou “no” si parent
est une Observation).
3) Le fichier lui\sphinxhyphen{}même a la structure suivante :
racine de l’arbre    \# ligne 1
{[}ligne vide{]}         \# ligne 2
noeud\_1              \# ligne 3
noeud\_2              \# ligne 4
…
noeud\_n              \# ligne n + 2
{[}ligne vide{]}         \# ligne n + 3
arc\_1                \# ligne n + 4
arc\_2                \# ligne n + 5
…
arc\_m                \# ligne n + m + 3
Cette méthode utilise également l’attribut self.fout\_newline pour
représenter le signe qui indique le début d’une nouvelle ligne.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filemame}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Le nom du fichier où on sauvegarde le texte.

\end{description}\end{quote}

\end{fulllineitems}

\index{visualize() (méthode StrategyTree.StrategyTree)@\spxentry{visualize()}\spxextra{méthode StrategyTree.StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.StrategyTree.visualize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{visualize}}}{\emph{filename=\textquotesingle{}last\_best\_strategy\_tree.gv\textquotesingle{}}}{}
Affiche l’arbre de stratégie via le module graphviz. L’image construit
est sauvegardé dans le fichier \sphinxstyleemphasis{filename.pdf}.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Le nom du fichier où on sauvegarde l’image.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{st\_from\_file() (dans le module StrategyTree)@\spxentry{st\_from\_file()}\spxextra{dans le module StrategyTree}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:StrategyTree.st_from_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{StrategyTree.}}\sphinxbfcode{\sphinxupquote{st\_from\_file}}}{\emph{filename=\textquotesingle{}last\_best\_tree.txt\textquotesingle{}}, \emph{sep=\textquotesingle{}}, \emph{\textquotesingle{}}, \emph{newline=None}}{}
Permet de créer un objet du type StrategyTree à partir du fichier indiqué
par \sphinxstyleemphasis{filename} en suivant le modèle fourni par la méthode
StrategyTree.to\_file.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Nom du fichier où l’arbre est stocké l’arbre sous forme textuelle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Le séparateur utilisé dans le fichier.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{newline}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{facultatif}}) \textendash{} Signe qui indique le début d’une nouvelle ligne.

\end{itemize}

\item[{Renvoie}] \leavevmode
\sphinxstylestrong{stin} \textendash{} L’arbre créé à partir des paramètres passés.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{index:StrategyTree.StrategyTree}]{\sphinxcrossref{StrategyTree}}}

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Index des modules Python}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{DecisionTheoreticTroubleshooting}\sphinxstyleindexpageref{index:\detokenize{module-DecisionTheoreticTroubleshooting}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{StrategyTree}\sphinxstyleindexpageref{index:\detokenize{module-StrategyTree}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}