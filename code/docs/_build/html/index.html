

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>Documentation du module Decision Theoretic Troubleshooting &#8212; Documentation Decision Theoretic Troubleshooting </title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Documentation Decision Theoretic Troubleshooting </a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-DecisionTheoreticTroubleshooting">
<span id="documentation-du-module-decision-theoretic-troubleshooting"></span><h1>Documentation du module Decision Theoretic Troubleshooting<a class="headerlink" href="#module-DecisionTheoreticTroubleshooting" title="Lien permanent vers ce titre">¶</a></h1>
<dl class="class">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem">
<em class="property">class </em><code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">TroubleShootingProblem</code><span class="sig-paren">(</span><em class="sig-param">bayesian_network</em>, <em class="sig-param">costs</em>, <em class="sig-param">nodes_types</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Classe créée pour représenter un problème de Troubleshooting.
Contient des méthodes divers pour résoudre le problème.
Utilise le module pyAgrum pour manipuler le réseau bayesien utilisé pour
répresenter le problème.
Les noeuds du réseau bayésien sont réferencés par des strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bayesian_network</strong> (<em>pyAgrum.BayesNet</em>) – Représente le réseau bayésien (BN) modélisant un problème donné.</p></li>
<li><p><strong>costs</strong> (<em>list</em><em>(</em><em>dict</em><em>)</em>) – Liste avec deux dictionnaires, le premier avec les coûts de
réparation (exactes ou avec des minimun/maximun) et le deuxième
avec les coûts d’observation des noeuds.</p></li>
<li><p><strong>nodes_types</strong> (<em>dict</em>) – Dictionnaire où les clés représent les noeuds du BN
et les valeurs leurs types associés (set de string).</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.bayesian_network">
<code class="sig-name descname">bayesian_network</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.bayesian_network" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Représente le réseau bayésien (BN) qui modélise un problème donné.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pyAgrum.BayesNet</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.bay_lp">
<code class="sig-name descname">bay_lp</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.bay_lp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fait l’inference exacte pour le BN passé en argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pyAgrum.LazyPropagation</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep">
<code class="sig-name descname">costs_rep</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts de reparation (float).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep_interval">
<code class="sig-name descname">costs_rep_interval</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_rep_interval" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Dictionnaire de coûts où les clés représentent les
noeuds du BN et les valeurs des listes avec les coûts minimum et
maximum de reparation (floats).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_obs">
<code class="sig-name descname">costs_obs</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.costs_obs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Dictionnaire de coûts où les clés représentent les noeuds
du BN et les valeurs leurs coûts d’observation (float).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.repairable_nodes">
<code class="sig-name descname">repairable_nodes</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.repairable_nodes" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ensemble de noeuds qui correspondent aux éléments du
système concerné qui peuvent être réparés.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.unrepairable_nodes">
<code class="sig-name descname">unrepairable_nodes</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.unrepairable_nodes" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ensemble de noeuds qui correspondent aux éléments
d’un système qui ne peuvent pas être réparés.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.problem_defining_node">
<code class="sig-name descname">problem_defining_node</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.problem_defining_node" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Noeud qui répresent le problème a être reglé
(système fonctionnel où pas).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_nodes">
<code class="sig-name descname">observation_nodes</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_nodes" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ensemble de noeuds qui correspondent aux éléments
du système qui peuvent être observés.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.service_node">
<code class="sig-name descname">service_node</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.service_node" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Noeud qui répresent l’appel au service (appel à la
réparation sûre du système).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.evidences">
<code class="sig-name descname">evidences</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.evidences" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Dictionnaire ou les clés répresentent les élements du
système qui ont des evidences modifiés dans bay_lp (donc qui ont
été réparés/observés) et les valeurs sont les inferences faites.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.ECR_ECO_wrapper">
<code class="sig-name descname">ECR_ECO_wrapper</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.ECR_ECO_wrapper" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Calcule l’ECR myope pour chaque prochaine « observation-réparation »
possible et l’ECO pour chaque prochaine observation globale possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>chosen_node</strong> (<em>string</em>) – Noeud choisi.</p></li>
<li><p><strong>type_node</strong> (<em>string</em>) – Type du noeud choisi (« repair » ou « obs »).</p></li>
<li><p><strong>list_ecr</strong> (<em>list(tuple)</em>) – ECRs des noeuds d“« observation-réparation ».</p></li>
<li><p><strong>list_eco</strong> (<em>list(tuple)</em>) – ECOs des noeuds d’observation globale.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem._compute_costs">
<code class="sig-name descname">_compute_costs</code><span class="sig-paren">(</span><em class="sig-param">costs</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem._compute_costs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Prend en argument un dictionnaire de couts qui peut avoir des valeurs
exactes ou des intervalles de valeurs (de la forme [minimum, maximum])
et le transforme en 2 dictionnaires, un avec les esperances de cout
pour chaque clé et l’autre avec des intervalles de valeurs pour chaque
clé.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>costs</strong> (<em>dict</em>) – Dictionnaire de couts où les clés représentent les noeuds
du BN et les valeurs sont de nombres ou de listes de deux
nombres.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>expected_cost</strong> (<em>dict</em>) – Dictionnaire où les clés représentent les noeuds du
BN et les valeurs l’esperance de cout de ce noeud. Si la valeur
initiale était déjà un nombre, ce nombre est seulement copié,
sinon on considère que la valeur est une variable aléatoire
avec une distribution uniforme dans l’intervalle et donc
l’esperance est la moyenne des extremités de l’intervalle.</p></li>
<li><p><strong>interval_cost</strong> (<em>dict</em>) – Dictionnaire où les clés représentent les noeuds du
BN et les valeurs sont des listes contenant les deux extremités
des intervalles dans lequels les couts se trouvent. Si la
valeur initiale était déjà un nombre, ce nombre est copié comme
les deux extremités. Si la valeur initiale était un iterable,
on le transforme en liste.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem._create_nodes">
<code class="sig-name descname">_create_nodes</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">rep_string='_repair'</em>, <em class="sig-param">obs_string='_observation'</em>, <em class="sig-param">obs_rep_couples=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem._create_nodes" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée des noeuds de StrategyTree à partir de leurs noms dans le réseau
Bayésien.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – Noms des noeuds de réparations/observations/
observations-réparations dans le réseau Bayésien à partir desquels
on crée les noeuds.</p></li>
<li><p><strong>rep_string</strong> (<em>string</em><em>, </em><em>facultatif</em>) – Dans le cas où on ne considère pas des couples, on utilise ce
paramètre comme un suffixe pour les noeuds de réparation pour les
séparer de ceux d’observation.</p></li>
<li><p><strong>obs_string</strong> (<em>string</em><em>, </em><em>facultatif</em>) – Suffixe pour les noeuds d’observation.</p></li>
<li><p><strong>obs_rep_couples</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Variable boléenne qui indique si on suppose l’existance de couples
« observation-réparation » dans l’arbre de stratégie.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>nodes</strong> – Liste de noeuds crées.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>list(NodeST)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem._expected_cost_of_repair_internal">
<code class="sig-name descname">_expected_cost_of_repair_internal</code><span class="sig-paren">(</span><em class="sig-param">strategy_tree</em>, <em class="sig-param">evid_init=None</em>, <em class="sig-param">prob=1.0</em>, <em class="sig-param">obs_obsolete=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem._expected_cost_of_repair_internal" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Partie récursive de la fonction expected_cost_of_repair.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strategy_tree</strong> (<em>StrategyTree</em>) – Arbre de stratégie dont le coût il faut calculer.</p></li>
<li><p><strong>evid_init</strong> (<em>dict</em><em>(</em><em>str: str</em><em>)</em><em>, </em><em>facultatif</em>) – Dictionnaire d’évidences utilisé dans les appels récursifs.</p></li>
<li><p><strong>prob</strong> (<em>float</em><em>, </em><em>facultatif</em>) – Probabilité initiale.</p></li>
<li><p><strong>obs_obsoletes</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, on remet en cause les noeuds d’observation globale après
une réparation.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>ecr</strong> – Coût espéré de réparation d’un arbre de stratégie fourni.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem._next_node_id">
<code class="sig-name descname">_next_node_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem._next_node_id" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Permet d’obtenir la prochaine valeur d’id pour le noeud courant de
StrategyTree.</p>
<dl class="field-list simple">
<dt class="field-odd">Renvoie</dt>
<dd class="field-odd"><p><strong>next_id</strong> – Prochaine valeur d’id.</p>
</dd>
<dt class="field-even">Type renvoyé</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem._start_bay_lp">
<code class="sig-name descname">_start_bay_lp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem._start_bay_lp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Ajoute des inférences vides aux noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés).Ces évidences ne changent pas les
probabilités, elles servent pour qu’on puisse utiliser la méthode
chgEvidence de pyAgrum à la suite.</p>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.add_evidence">
<code class="sig-name descname">add_evidence</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">evidence</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.add_evidence" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fonction wrapper pour la fonction chgEvidence de l’objet bay_lp du
type pyAgrum.LazyPropagation qui additionne une inference et mantient
le dictionnaire evidences actualisé. L’evidence passé en argument ne
doit pas être une evidence « vide » (des 1, utilisé plutôt la fonction
remove_evidence).</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>string</em>) – Nom du noeud de bay_lp qui va être modifié.</p></li>
<li><p><strong>evidence</strong> – Nouvelle inference pour le noeud traité (généralement
une string ici, cf. les types acceptés par chgEvidence)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.best_EVOI">
<code class="sig-name descname">best_EVOI</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.best_EVOI" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Détermine la composante qui a la plus grande valeur espérée
d’information (EVOI) correspondant à avoir plus d’information sur
l’intervalle de valeur de son cout.</p>
<dl class="field-list simple">
<dt class="field-odd">Renvoie</dt>
<dd class="field-odd"><p>Le nom du noeud de réparation avec la plus grande EVOI et la valeur
d’EVOI correspondante.</p>
</dd>
<dt class="field-even">Type renvoyé</dt>
<dd class="field-even"><p>tuple(string, float)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_actions_only">
<code class="sig-name descname">brute_force_solver_actions_only</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_actions_only" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Cherche une séquence optimale de réparation par une recherche
exhaustive en choisissant la séquence de meilleur ECR. Pour le cas où
on ne considère que les actions de réparation il suffit de dénombrer
toutes les permutations possibles d’un ensemble des actions
admissibles.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>min_seq</strong> (<em>list(str)</em>) – Séquence optimale trouvée dont le coût est le plus petit possible.</p></li>
<li><p><strong>min_ecr</strong> (<em>float</em>) – Coût espéré de réparation correspondant à min_seq.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_tester">
<code class="sig-name descname">brute_force_solver_tester</code><span class="sig-paren">(</span><em class="sig-param">true_prices</em>, <em class="sig-param">epsilon</em>, <em class="sig-param">nb_min=100</em>, <em class="sig-param">nb_max=200</em>, <em class="sig-param">strategy_tree=None</em>, <em class="sig-param">mode='dp'</em>, <em class="sig-param">obs_rep_couples=False</em>, <em class="sig-param">true_prices_obs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.brute_force_solver_tester" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Test empirique de la méthode brute_force_solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>true_prices</strong> (<em>dict</em>) – Dictionnaire de prix de réparation des composantes réparables.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – Tolerance relative de la moyenne.</p></li>
<li><p><strong>nb_min</strong> (<em>int</em>) – Nombre minimum de répétitions à être realisées.</p></li>
<li><p><strong>nb_max</strong> (<em>int</em>) – Nombre maximum de répétitions à être realisées.</p></li>
<li><p><strong>strategy_tree</strong> (<em>StrategyTree</em><em>, </em><em>facultatif</em>) – Arbre de stratégie qu’il faut tester ; si rien passé, on calcule
l’arbre avec la méthode brute_force_solver.</p></li>
<li><p><strong>mode</strong> (<em>string</em><em>, </em><em>facultatif</em>) – Paramètre à passer à la méthode brute_force_solver si on doit
l’exécuter. Peut être égal à “all” pour le dénombrement complet ou
“dp” pour la programmation dynamique.</p></li>
<li><p><strong>obs_rep_couples</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – <dl class="simple">
<dt>Paramètre à passer à la méthode brute_force_solver si on doit</dt><dd><p>l’exécuter. Indique si on suppose l’existance de couples
« observation-réparation » dans l’arbre de stratégie.</p>
</dd>
<dt>true_prices_obs<span class="classifier">dict, facultatif</span></dt><dd><p>Dictionnaire de prix d’observations des composantes observables.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sortie_anti</strong> (<em>bool</em>) – True en cas de sortie anticipée, False sinon.</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Moyenne des couts observés.</p></li>
<li><p><strong>cpt_repair</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de composantes réparées à chaque répétition.</p></li>
<li><p><strong>cpt_obs</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre d’observations globales faites à chaque
répétition.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.compute_EVOIs">
<code class="sig-name descname">compute_EVOIs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.compute_EVOIs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Calcule les valeurs espérées d’information (EVOIs) correspondant à
avoir plus d’information sur l’intervalle de valeur des couts de
réparation pour chaque composante réparable.</p>
<dl class="field-list simple">
<dt class="field-odd">Renvoie</dt>
<dd class="field-odd"><p><strong>evoi</strong> – Dictionnaire indexé par les noeuds réparables contenant la valeur
d’une information plus précise du cout de réparation de ces noeuds.</p>
</dd>
<dt class="field-even">Type renvoyé</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.draw_true_prices">
<code class="sig-name descname">draw_true_prices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.draw_true_prices" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Tire au hasard des prix de réparation selon des lois uniformes sur les
intervalles stockés dans self.costs_rep_interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Renvoie</dt>
<dd class="field-odd"><p>Dictionnaire avec prix de réparation.</p>
</dd>
<dt class="field-even">Type renvoyé</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation">
<code class="sig-name descname">elicitation</code><span class="sig-paren">(</span><em class="sig-param">noeud</em>, <em class="sig-param">islower</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Met à jour l’intervalle de valeurs de cout pour le noeud et son
espérance en fonction de la réponse de l’utilisateur.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noeud</strong> (<em>string</em>) – Nom du noeud à mettre à jour.</p></li>
<li><p><strong>islower</strong> (<em>bool</em>) – Représente la réponse à la question : Est-ce que le cout est plus
petit que l’espérance courante ?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation_solver_tester">
<code class="sig-name descname">elicitation_solver_tester</code><span class="sig-paren">(</span><em class="sig-param">true_prices</em>, <em class="sig-param">epsilon</em>, <em class="sig-param">nb_min=100</em>, <em class="sig-param">nb_max=200</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.elicitation_solver_tester" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Test empirique de la résolution avec élicitation. À chaque fois qu’on
doit prendre une action, on vérifie d’abord s’il y a des questions à
répondre et, si oui, on les répond toutes correctement selon
true_prices. Ensuite, la méthode calcule la séquence d’actions
itérativement à l’aide de myopic_solver et réalise au plus nb_max
repetitions d’un système tiré au hasard, le tirage au hasard étant
identique à celui de myopic_solver_tester. Si après nb_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true_prices.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>true_prices</strong> (<em>dict</em>) – Dictionnaire de prix de réparation des composantes réparables.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – Tolerance relative de la moyenne.</p></li>
<li><p><strong>nb_min</strong> (<em>int</em>) – Nombre minimum de répétitions à être realisées.</p></li>
<li><p><strong>nb_max</strong> (<em>int</em>) – Nombre maximum de répétitions à être realisées.</p></li>
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sortie_anti</strong> (<em>bool</em>) – True en cas de sortie anticipée, False sinon.</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Moyenne des couts observés.</p></li>
<li><p><strong>cpt_repair</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de composantes réparées à chaque répétition.</p></li>
<li><p><strong>cpt_obs</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre d’observations globales faites à chaque
répétition.</p></li>
<li><p><strong>cpt_questions</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de questions répondues à chaque répétition.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair">
<code class="sig-name descname">expected_cost_of_repair</code><span class="sig-paren">(</span><em class="sig-param">strategy_tree</em>, <em class="sig-param">obs_obsolete=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Calcule le coût espéré de réparation étant donné un arbre de décision.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strategy_tree</strong> (<em>StrategyTree</em>) – Arbre de stratégie dont le coût il faut calculer.</p></li>
<li><p><strong>obs_obsoletes</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, on remet en cause les noeuds d’observation globale après
une réparation.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>ecr</strong> – Coût espéré de réparation d’un arbre de stratégie fourni.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair_seq_of_actions">
<code class="sig-name descname">expected_cost_of_repair_seq_of_actions</code><span class="sig-paren">(</span><em class="sig-param">seq</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.expected_cost_of_repair_seq_of_actions" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Calcule un coût espéré de réparation à partir d’une séquence d’actions
donnée. On utilise la formule
ECR = coût(C1 | E0)
+ P(C1 = Normal | E0) * coût(C2 | E1)
+ P(C1 = Normal | E0) * P(C2 = Normal | E1) * coût(C2 | E2)
+ …</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – Séquence d’actions de réparations dont le coût espéré est à
calculer.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>ecr</strong> – Coût espéré de réparation de la séquence donnée.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.get_proba">
<code class="sig-name descname">get_proba</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.get_proba" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Récupère à partir du réseau bayésien la probabilité que le noeud node
ait la valeur value.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>string</em>) – Nom du noeud de bay_lp dont on veut calculer la probabilité.</p></li>
<li><p><strong>value</strong> (<em>string</em>) – Valeur du noeud dont on veut calculer la probabilité.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p>La probabilité P(node = value)</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver">
<code class="sig-name descname">myopic_solver</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em>, <em class="sig-param">esp_obs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Implémente une étape du solveur myope. Étant donné l’état actuel du
réseau, ce solveur utilise dans un premier temps le simple_solver_obs
pour déterminer quelle action du type « observation-réparation » serait
la meilleure. Ensuite, il calcule les coûts myopes espérés avec chaque
observation possible et choisit à la fin la meilleure action à être
prise.</p>
<p>Cette fonction est itérative et ne fait qu’un seul tour de
l’algorithme myope car elle attend des nouvelles informations venues
de l’utilisateur (résultat de l’observation si c’est le cas).</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p></li>
<li><p><strong>esp_obs</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, retourne en plus un dictionnaire indexé par les
observations possibles et contenants leurs couts myopes espérés
respectifs.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>chosen_node</strong> (<em>string</em>) – Le meilleur noeud de ce tour</p></li>
<li><p><strong>type_node</strong> (<em>string</em>) – Type du meilleur noeud (« repair » ou « obs »)</p></li>
<li><p><strong>eco</strong> (<em>dict</em>) – Retourné uniquement lorsque esp_obs vaut True. Dictionnaire des
couts espérés des observations.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_tester">
<code class="sig-name descname">myopic_solver_tester</code><span class="sig-paren">(</span><em class="sig-param">true_prices</em>, <em class="sig-param">epsilon</em>, <em class="sig-param">nb_min=100</em>, <em class="sig-param">nb_max=200</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_solver_tester" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Test empirique de la méthode myopic_solver. Cette méthode calcule
la séquence d’actions itérativement à l’aide de myopic_solver et
réalise au plus nb_max repetitions d’un système tiré au hasard. À
chaque observation globale, son résultat est tiré au hasard. Pour les
paires « observation-réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true_prices.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>true_prices</strong> (<em>dict</em>) – Dictionnaire de prix de réparation des composantes réparables.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – Tolerance relative de la moyenne.</p></li>
<li><p><strong>nb_min</strong> (<em>int</em>) – Nombre minimum de répétitions à être realisées.</p></li>
<li><p><strong>nb_max</strong> (<em>int</em>) – Nombre maximum de répétitions à être realisées.</p></li>
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sortie_anti</strong> (<em>bool</em>) – True en cas de sortie anticipée, False sinon.</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Moyenne des couts observés.</p></li>
<li><p><strong>cpt_repair</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de composantes réparées à chaque répétition.</p></li>
<li><p><strong>cpt_obs</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre d’observations globales faites à chaque
répétition.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_wraper">
<code class="sig-name descname">myopic_wraper</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.myopic_wraper" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Interface textuelle pour le solveur myope. Utilise myopic_solver à
chaque tour de boucle pour déterminer la meilleure action à prendre.
Si c’est une observation, le résultat de l’observation est demandé,
sinon on demande juste si l’action a résolu le problème. Les
élicitations de couts ne sont pas implémentées. Les entrées de
l’utilisateur ne sont pas sécurisées.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.noeud_ant">
<code class="sig-name descname">noeud_ant</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">visites</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.noeud_ant" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Détermine tous les noeuds d’observation impactés par un changement
du noeud node et qui sont antécesseurs de node, sans visiter les noeuds
déjà dans l’ensemble des visites. Cette fonction est auxiliaire et n’a
pas vocation à être appellée en dehors de la fonction principale
observation_obsolete.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>string</em>) – Nom du noeud don l’information a changé.</p></li>
<li><p><strong>visites</strong> (<em>set</em>) – Contient les noeuds déjà visités.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>ant_obs</strong> – Ensemble des noeuds d’observation affectés par node et qui sont
antecesseurs de node sans être dans visites.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_obsolete">
<code class="sig-name descname">observation_obsolete</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.observation_obsolete" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Étant donné un noeud dont l’information a changé, on détermine, à
partir du réseau bayésien, tous les noeuds d’observation impactés par
ce chagement.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>node</strong> (<em>string</em>) – Nom du noeud dont l’information a changé.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>obs</strong> – Ensemble contenant les noeuds d’observation impactés.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.prob_val">
<code class="sig-name descname">prob_val</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.prob_val" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Retourne la probabilité a posteriori qu’une variable <em>var</em> soit égale à
<em>value</em> sachant l’évidence courante du réseau bayésien (cette évidence
doit être mise en place avant l’appel à cette fonction).</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<em>str</em>) – Nom de la variable aléatoire.</p></li>
<li><p><strong>value</strong> (<em>str</em>) – Valeur de la variable aléatoire.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>prob</strong> – Probabilité que <em>var</em> soit égale à <em>value</em> sachant l’évidence
courante de notre réseau bayésien, i.e., prob = P(var = value | E),
où E est l’évidence courante.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.remove_evidence">
<code class="sig-name descname">remove_evidence</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.remove_evidence" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fonction wrapper pour la fonction chgEvidence de l’objet bay_lp du
type pyAgrum.LazyPropagation qui retire une inference et mantient le
dictionnaire evidences actualisé.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>node</strong> (<em>string</em>) – Nom du noeud de bay_lp qui va être modifié.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.reset_bay_lp">
<code class="sig-name descname">reset_bay_lp</code><span class="sig-paren">(</span><em class="sig-param">dict_inf={}</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.reset_bay_lp" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Reinitialise les inférences des noeuds du BN qui peuvent être modifiés
(réparés/observés/appelés). Pour les noeuds dans dict_inf, l’inférence
est mis à la valeur associé au noeud dans dict_inf, pour les autres
l’inférence est mis à 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>dict_inf</strong> (<em>dict</em><em>, </em><em>facultatif</em>) – Dictionnaire où les clés sont des noeuds et les valeurs sont des
inférences.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver">
<code class="sig-name descname">simple_solver</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Solveur simple pour le problème du TroubleShooting.
On ne prend pas en considèration des observations et on ne révise pas
les probabilités, c’est-à-dire on ne met pas à jour les probabilités
si on répare une composante.
À cause de cela, ce solveur n’est pas iteractif et renvoie l’ordre de
réparation entière (jusqu’au appel au service).</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rep_seq</strong> (<em>list</em>) – Séquence des noeuds à être réparés dans l’ordre.</p></li>
<li><p><strong>exp_cost</strong> (<em>float</em>) – Espérance du coût de réparation de cette séquence.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs">
<code class="sig-name descname">simple_solver_obs</code><span class="sig-paren">(</span><em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Solveur simple pour le problème du Troubleshooting.
On prend en considèration des paires « observation-réparation » (cf.
définition dans l’état de l’art) mais pas les observations globales
et on révise les probabilités, c’est-à-dire on met à jour les
probabilités quand on « répare » une composante avant de calculer le
prochaine composante de la séquence.</p>
<p>Le solveur n’est pas encore iteractif et renvoie l’ordre de réparation
entière (jusqu’au appel au service). Cette choix à été fait car on
utilise cet algorithme comme part de l’agorithme plus complexe et
iteratif.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>debug</strong> (<em>bool</em><em>, </em><em>facultatif</em>) – Si True, affiche des messages montrant le déroulement de
l’algorithme.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rep_seq</strong> (<em>list</em>) – Séquence des noeuds à être réparés dans l’ordre.</p></li>
<li><p><strong>exp_cost</strong> (<em>float</em>) – Espérance du coût de réparation de cette séquence.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs_tester">
<code class="sig-name descname">simple_solver_obs_tester</code><span class="sig-paren">(</span><em class="sig-param">true_prices</em>, <em class="sig-param">epsilon</em>, <em class="sig-param">nb_min=100</em>, <em class="sig-param">nb_max=200</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_obs_tester" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Test empirique de la méthode simple_solver_obs. Cette méthode calcule
la séquence d’actions à l’aide de simple_solver_obs et réalise au plus
nb_max répétitions d’un système tiré au hasard : si on a une paire
« observation-réparation », on tire au hasard si la composante
correspondante marche ou pas. Si oui, on ajoute juste le cout de
l’observation et on continue, si non, on ajoute les couts d’observation
et de réparation et on s’arrête (single fault assumption). Si on a
une réparation simple sans observation associée, on ajoute directement
le cout de réparation de la composante. Si après nb_min repétitions
l’erreur estimée est plus petite que epsilon, on fait une sortie
anticipée. La fonction calcule les couts empiriques de réparation, en
utilisant pour cela true_prices.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>true_prices</strong> (<em>dict</em>) – Dictionnaire de prix de réparation des composantes réparables.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – Tolerance relative de la moyenne.</p></li>
<li><p><strong>nb_min</strong> (<em>int</em>) – Nombre minimum de répétitions à être realisées.</p></li>
<li><p><strong>nb_max</strong> (<em>int</em>) – Nombre maximum de répétitions à être realisées.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sortie_anti</strong> (<em>bool</em>) – True en cas de sortie anticipée, False sinon.</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Moyenne des couts observés.</p></li>
<li><p><strong>cpt_repair</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de composantes réparées à chaque répétition.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_tester">
<code class="sig-name descname">simple_solver_tester</code><span class="sig-paren">(</span><em class="sig-param">true_prices</em>, <em class="sig-param">epsilon</em>, <em class="sig-param">nb_min=100</em>, <em class="sig-param">nb_max=200</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.TroubleShootingProblem.simple_solver_tester" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Test empirique de la méthode simple_solver. Cette méthode calcule la
séquence d’actions à l’aide de simple_solver et réalise au plus nb_max
repétitions d’un système tiré au hasard : à chaque fois qu’on a une
probabilité qu’une action résoud le problème, on tire au hasard pour
déterminer si le problème a effectivement été résolu ou pas suite à
cette action. Si après nb_min repétitions l’erreur estimée est plus
petite que epsilon, on fait une sortie anticipée. La fonction calcule
aussi les couts empiriques de réparation, en utilisant pour cela
true_prices. Cette méthode utilise la single fault assumption.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>true_prices</strong> (<em>dict</em>) – Dictionnaire de prix de réparation des composantes réparables.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – Tolerance relative de la moyenne.</p></li>
<li><p><strong>nb_min</strong> (<em>int</em>) – Nombre minimum de répétitions à être realisées.</p></li>
<li><p><strong>nb_max</strong> (<em>int</em>) – Nombre maximum de répétitions à être realisées.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sortie_anti</strong> (<em>bool</em>) – True en cas de sortie anticipée, False sinon.</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Moyenne des couts observés.</p></li>
<li><p><strong>cpt_repair</strong> (<em>numpy.ndarray</em>) – Tableau avec le nombre de composantes réparées à chaque répétition.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="DecisionTheoreticTroubleshooting.bcolors">
<em class="property">class </em><code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">bcolors</code><a class="headerlink" href="#DecisionTheoreticTroubleshooting.bcolors" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Stockage de couleurs.</p>
</dd></dl>

<dl class="function">
<dt id="DecisionTheoreticTroubleshooting.diff_dicts">
<code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">diff_dicts</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">right</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.diff_dicts" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Calcule la différence des dictionnaires <em>left</em> et <em>right</em> : les entrées de
<em>left</em> dont la clé est aussi présente dans <em>right</em> sont supprimées, les
autres sont gardées.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> (<em>dict</em>) – Premier dictionnaire, duquel on supprime les clés apparaissant dans
<em>right</em>.</p></li>
<li><p><strong>right</strong> (<em>dict</em>) – Deuxième dictionnaire, celui avec les clés qui doivent être supprimées
de <em>left</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>res</strong> – Résultat de la différence entre <em>left</em> et <em>right</em>.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DecisionTheoreticTroubleshooting.merge_dicts">
<code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">merge_dicts</code><span class="sig-paren">(</span><em class="sig-param">left</em>, <em class="sig-param">right</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.merge_dicts" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Fusionne deux dictionnaire passés sans les changer. Les couples (clé,
valeur) du dictionnaire <em>right</em> sont plus prioritaires que celles de
<em>left</em> ; c’est-à-dire, s’il existe une valeur associée à la même clé k dans
les deux dictionnaires, on ajoute dans le résultat seulement celle qui
appartient à <em>right</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> (<em>dict</em>) – Un des dictionnaires à fusionner, celui qui est moins prioritaire.</p></li>
<li><p><strong>right</strong> (<em>dict</em>) – L’autre dictionnaire à fusionner, celui qui est plus prioritaire.</p></li>
</ul>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>res</strong> – Résultat de la fusion.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DecisionTheoreticTroubleshooting.shallow_copy_list_of_copyable">
<code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">shallow_copy_list_of_copyable</code><span class="sig-paren">(</span><em class="sig-param">l</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.shallow_copy_list_of_copyable" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée une copie de profondeur 1 de la liste passée en argument : la liste
est recopiée et remplie avec l’appel de la méthode copy() en chaque élément
de la liste donnée.</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>l</strong> (<em>list&lt;Copyable&gt;</em>) – La liste qui sera copiée. Chacun de ses éléments doit implémenter la
méthode copy().</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>cl</strong> – Copie de profondeur 1 de la liste passée en argument.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>list&lt;Copyable&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DecisionTheoreticTroubleshooting.shallow_copy_parent">
<code class="sig-prename descclassname">DecisionTheoreticTroubleshooting.</code><code class="sig-name descname">shallow_copy_parent</code><span class="sig-paren">(</span><em class="sig-param">parent</em><span class="sig-paren">)</span><a class="headerlink" href="#DecisionTheoreticTroubleshooting.shallow_copy_parent" title="Lien permanent vers cette définition">¶</a></dt>
<dd><p>Crée une copie superficielle de <em>parent</em> (cf la méthode
TroubleShootingProblem._evaluate_all_st ci-dessous).</p>
<dl class="field-list simple">
<dt class="field-odd">Paramètres</dt>
<dd class="field-odd"><p><strong>parent</strong> (<em>list&lt;tuple&lt;NodeST</em><em>, </em><em>NodeST</em><em>, </em><em>StrategyTree&gt;&gt;</em>) – Parent dont la copie il faut créer.</p>
</dd>
<dt class="field-even">Renvoie</dt>
<dd class="field-even"><p><strong>parent_copy</strong> – Copie superficielle du parent passé.</p>
</dd>
<dt class="field-odd">Type renvoyé</dt>
<dd class="field-odd"><p>list&lt;tuple&lt;NodeST, NodeST, StrategyTree&gt;&gt;</p>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Documentation Decision Theoretic Troubleshooting </a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Ariana Carnielli, Ivan Kachaikin.
      Créé avec <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>